<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Johan Commelin. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johan Commelin, Fabian Glöckle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import linear_algebra.tensor_product</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/tensor_product.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import linear_algebra.finite_dimensional</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import tactic.apply_fun</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/apply_fun.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  # Dual vector spaces</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  The dual space of an R-module M is the R-module of linear maps `M → R`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  * `dual R M` defines the dual space of M over R.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  * Given a basis for a K-vector space `V`, `is_basis.to_dual` produces a map from `V` to `dual K V`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  * Given families of vectors `e` and `ε`, `dual_pair e ε` states that these families have the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    characteristic properties of a basis and a dual.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  ## Main results</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  * `to_dual_equiv` : the dual space is linearly equivalent to the primal space.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  * `dual_pair.is_basis` and `dual_pair.eq_dual`: if `e` and `ε` form a dual pair, `e` is a basis and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    `ε` is its dual basis.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  ## Notation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  We sometimes use `V&#x27;` as local notation for `dual K V`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  ## Implementation details</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  Because of unresolved type class issues, the following local instance can be of use:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  private def help_tcs : has_scalar K V := mul_action.to_has_scalar _ _</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  local attribute [instance] help_tcs</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  namespace module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  variables (R : Type*) (M : Type*)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  variables [comm_ring R] [add_comm_group M] [module R M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='comm_ring.{u_1} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='add_comm_group.{u_2} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  /-- The dual space of an R-module M is the R-module of linear maps `M → R`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  @[derive [add_comm_group, module R]] def dual := M →ₗ[R] R</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) (γ : Type u_1) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : add_comm_group.{u_1} γ] [_inst_4 : @module.{u_1 u_2} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 u_1} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) (γ : Type u_1) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : add_comm_group.{u_1} γ] [_inst_4 : @module.{u_1 u_2} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 u_1} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='automatically derive typeclass instances'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  namespace dual</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  instance : inhabited (dual R M) := by unfold dual; apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
⊢ inhabited.{(max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
⊢ inhabited.{(max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  instance : has_coe_to_fun (dual R M) := ⟨_, linear_map.to_fun⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='linear_map.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{w} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u w} α γ _inst_1 _inst_3], @linear_map.{u v w} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  /-- Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  `vector_space.eval_equiv`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  def eval : M →ₗ[R] (dual R (dual R M)) := linear_map.id.flip</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='linear_map.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/tensor_product.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) (γ : Type (max u_2 u_1)) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : add_comm_group.{(max u_2 u_1)} γ] [_inst_4 : @module.{u_1 u_2} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 (max u_2 u_1)} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) (γ : Type (max u_2 u_1)) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : add_comm_group.{(max u_2 u_1)} γ] [_inst_4 : @module.{u_1 u_2} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 (max u_2 u_1)} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} {β : Type (max u_2 u_1)} [rα : ring.{u_1} α] [gβ : add_comm_group.{(max u_2 u_1)} β] [mβ : @module.{u_1 (max u_2 u_1)} α β rα gβ], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α β β rα gβ gβ mβ mβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u_1} [_inst_1 : comm_ring.{u_1} R] {M : Type (max u_2 u_1)} {N : Type u_2} {P : Type u_1} [_inst_2 : add_comm_group.{(max u_2 u_1)} M] [_inst_3 : add_comm_group.{u_2} N] [_inst_4 : add_comm_group.{u_1} P] [_inst_6 : @module.{u_1 (max u_2 u_1)} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2] [_inst_7 : @module.{u_1 u_2} R N (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3] [_inst_8 : @module.{u_1 u_1} R P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_4], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M (@linear_map.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u_1 u_2 u_1} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) → @linear_map.{u_1 u_2 (max u_2 u_1)} R N (@linear_map.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u_1 (max u_2 u_1) u_1} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  lemma eval_apply (v : M) (a : dual R M) : (eval R M v) a = a v :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='module.dual.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @linear_map.{u_1 u_2 (max u_2 u_1)} R M (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and
`vector_space.eval_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))}
       (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@module.dual.has_coe_to_fun.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))}
          (@linear_map.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@module.dual.eval.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          v)
       a)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    dunfold eval,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))}
       (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@module.dual.has_coe_to_fun.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))}
          (@linear_map.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@module.dual.eval.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          v)
       a)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))}
       (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@module.dual.has_coe_to_fun.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))}
          (@linear_map.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.flip.{u_1 (max u_2 u_1) u_2 u_1} R _inst_1
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             M
             R
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_2
             (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_3
             (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.id.{u_1 (max u_2 u_1)} R
                (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@comm_ring.to_ring.{u_1} R _inst_1)
                (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))))
          v)
       a)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    rw [linear_map.flip_apply, linear_map.id_apply]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='linear_map.flip_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.id_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/tensor_product.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 207, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} [_inst_1 : comm_ring.{u_1} R] {M : Type (max u_2 u_1)} {N : Type u_2} {P : Type u_1} [_inst_2 : add_comm_group.{(max u_2 u_1)} M] [_inst_3 : add_comm_group.{u_2} N] [_inst_4 : add_comm_group.{u_1} P] [_inst_6 : @module.{u_1 (max u_2 u_1)} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2] [_inst_7 : @module.{u_1 u_2} R N (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3] [_inst_8 : @module.{u_1 u_1} R P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_4] (f : @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M (@linear_map.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u_1 u_2 u_1} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (m : M) (n : N), @eq.{u_1+1} P (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))} (@linear_map.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))} (@linear_map.{u_1 u_2 (max u_2 u_1)} R N (@linear_map.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u_1 (max u_2 u_1) u_1} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)) (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R N (@linear_map.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u_1 (max u_2 u_1) u_1} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u_1 (max u_2 u_1) u_1} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)) (@linear_map.flip.{u_1 (max u_2 u_1) u_2 u_1} R _inst_1 M N P _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f) n) m) (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@linear_map.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@linear_map.has_coe_to_fun.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1} (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M (@linear_map.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u_1 u_2 u_1} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} R M (@linear_map.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u_1 u_2 u_1} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u_1 u_2 u_1} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) f m) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type (max u_2 u_1)} [rα : ring.{u_1} α] [gβ : add_comm_group.{(max u_2 u_1)} β] [mβ : @module.{u_1 (max u_2 u_1)} α β rα gβ] (x : β), @eq.{(max u_2 u_1)+1} β (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1} (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α β β rα gβ gβ mβ mβ) (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α β β rα gβ gβ mβ mβ) (@linear_map.id.{u_1 (max u_2 u_1)} α β rα gβ mβ) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))}
       (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@module.dual.has_coe_to_fun.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))}
          (@linear_map.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.flip.{u_1 (max u_2 u_1) u_2 u_1} R _inst_1
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             M
             R
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_2
             (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_3
             (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.id.{u_1 (max u_2 u_1)} R
                (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@comm_ring.to_ring.{u_1} R _inst_1)
                (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))))
          v)
       a)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))}
       (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
          (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
          _inst_3
          (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
          (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
          _inst_3
          (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
       (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
          (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))))
          (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} R
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))))
          (@linear_map.id.{u_1 (max u_2 u_1)} R
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))))
          a)
       v)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
v : M,
a : @module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3
⊢ @eq.{u_1+1} R
    (@coe_fn.{(max ((max u_2 u_1)+1) (u_1+1)) (max ((max u_2 u_1)+1) (u_1+1))}
       (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@module.dual.has_coe_to_fun.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
          (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
       (@coe_fn.{(max (u_2+1) ((max u_2 u_1)+1)) (max (u_2+1) ((max u_2 u_1)+1))}
          (@linear_map.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_2 u_1)} R M
             (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             (@comm_ring.to_ring.{u_1} R _inst_1)
             _inst_2
             (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))
             _inst_3
             (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1
                (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
                (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
          (@linear_map.flip.{u_1 (max u_2 u_1) u_2 u_1} R _inst_1
             (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             M
             R
             (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_2
             (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                _inst_3
                (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
             _inst_3
             (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
             (@linear_map.id.{u_1 (max u_2 u_1)} R
                (@linear_map.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@comm_ring.to_ring.{u_1} R _inst_1)
                (@linear_map.add_comm_group.{u_1 u_2 u_1} R M R (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))
                (@linear_map.module.{u_1 u_2 u_1} R M R _inst_1 _inst_2
                   (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))
                   _inst_3
                   (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)))))
          v)
       a)
    (@coe_fn.{(max (u_2+1) (u_1+1)) (max (u_2+1) (u_1+1))} (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@module.dual.has_coe_to_fun.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       a
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  end dual</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  end module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  namespace is_basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  universes u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  variables {K : Type u} {V : Type v} {ι : Type w}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  open vector_space module module.dual submodule linear_map cardinal function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  instance dual.vector_space : vector_space K (dual K V) := { ..module.dual.inst K V }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='module.dual.inst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @module.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@comm_ring.to_ring.{u_1} R _inst_1) (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  variables [de : decidable_eq ι]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Sort u → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  variables {B : ι → V} (h : is_basis K B)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  include de h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  /-- The linear map from a vector space equipped with basis to its dual vector space,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  taking basis elements to corresponding dual basis elements. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  def to_dual : V →ₗ[K] module.dual K V :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type (max v u)) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{(max v u)} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type (max v u)) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{(max v u)} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  h.constr $ λ v, h.constr $ λ w, if w = v then 1 else 0</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.constr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.constr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type (max v u)} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M&#x27; _inst_1 _inst_3], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → (ι → M&#x27;) → @linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type u} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{u} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u u} R M&#x27; _inst_1 _inst_3], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → (ι → M&#x27;) → @linear_map.{u v u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Construct a linear map given the value at the basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Construct a linear map given the value at the basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  lemma to_dual_apply (i j : ι) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    (h.to_dual (B i)) (B j) = if i = j then 1 else 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    by erw [constr_basis h, constr_basis h]; ac_refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='constr_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='constr_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 778, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 778, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1294, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type (max v u)} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M&#x27; _inst_1 _inst_3] {f : ι → M&#x27;} {i : ι} (hv : @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4), @eq.{(max v u)+1} M&#x27; (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@is_basis.constr.{w u v (max v u)} ι R M M&#x27; v _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 hv f) (v i)) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type u} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{u} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u u} R M&#x27; _inst_1 _inst_3] {f : ι → M&#x27;} {i : ι} (hv : @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4), @eq.{u+1} M&#x27; (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@is_basis.constr.{w u v u} ι R M M&#x27; v _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 hv f) (v i)) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `ac_reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ac_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B i))
       (B j))
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.constr.{w u v u} ι K V K B
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          h
          (λ (w : ι),
             @ite.{u+1} (@eq.{w+1} ι w i) ((λ (a b : ι), de a b) w i) K
               (@has_one.one.{u} K
                  (@zero_ne_one_class.to_has_one.{u} K
                     (@domain.to_zero_ne_one_class.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@has_zero.zero.{u} K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (B j))
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι j i) ((λ (a b : ι), de a b) j i) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B i))
       (B j))
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1294, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `ac_reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='ac_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B i))
       (B j))
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  def to_dual_flip (v : V) : (V →ₗ[K] K) := (linear_map.flip h.to_dual).to_fun v</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='linear_map.flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/tensor_product.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {R : Type u_1} [_inst_1 : comm_ring.{u_1} R] {M : Type u_2} {N : Type u_3} {P : Type u_4} [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : add_comm_group.{u_3} N] [_inst_4 : add_comm_group.{u_4} P] [_inst_6 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2] [_inst_7 : @module.{u_1 u_3} R N (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3] [_inst_8 : @module.{u_1 u_4} R P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_4], @linear_map.{u_1 u_2 (max u_3 u_4)} R M (@linear_map.{u_1 u_3 u_4} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u_1 u_3 u_4} R N P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u_1 u_3 u_4} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) → @linear_map.{u_1 u_3 (max u_2 u_4)} R N (@linear_map.{u_1 u_2 u_4} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u_1 u_2 u_4} R M P (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u_1 u_2 u_4} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type (max v u)} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{(max v u)} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} α γ _inst_1 _inst_3], @linear_map.{u v (max v u)} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  omit de h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  /-- Evaluation of finitely supported functions at a fixed point `i`, as a `K`-linear map. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  def eval_finsupp_at (i : ι) : (ι →₀ K) →ₗ[K] K :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) (β : Type (max w u)) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{(max w u)} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u (max w u)} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β : Type (max w u)) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{(max w u)} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u (max w u)} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  { to_fun := λ f, f i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    add := by intros; rw finsupp.add_apply,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='finsupp.add_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 405, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : add_monoid.{u} β] {g₁ g₂ : @finsupp.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)} {a : α}, @eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) (@finsupp.has_coe_to_fun.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) (@has_add.add.{(max w u)} (@finsupp.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) (@finsupp.has_add.{w u} α β _inst_1) g₁ g₂) a) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β _inst_1)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) (@finsupp.has_coe_to_fun.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) g₁ a) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) (@finsupp.has_coe_to_fun.{w u} α β (@add_monoid.to_has_zero.{u} β _inst_1)) g₂ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='K : Type u,
ι : Type w,
_inst_1 : discrete_field.{u} K,
i : ι
⊢ ∀
  (x y :
    @finsupp.{w u} ι K
      (@no_zero_divisors.to_has_zero.{u} K
         (@domain.to_no_zero_divisors.{u} K
            (@division_ring.to_domain.{u} K
               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@has_add.add.{(max w u)}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@add_semigroup.to_has_add.{(max w u)}
               (@finsupp.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@add_monoid.to_add_semigroup.{(max w u)}
                  (@finsupp.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@add_group.to_add_monoid.{(max w u)}
                     (@finsupp.{w u} ι K
                        (@no_zero_divisors.to_has_zero.{u} K
                           (@domain.to_no_zero_divisors.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                     (@add_comm_group.to_add_group.{(max w u)}
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
            x
            y)
         i)
      (@has_add.add.{u} K
         (@add_semigroup.to_has_add.{u} K
            (@add_monoid.to_add_semigroup.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            x
            i)
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            y
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
ι : Type w,
_inst_1 : discrete_field.{u} K,
i : ι,
x y :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_add.add.{(max w u)}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@add_semigroup.to_has_add.{(max w u)}
             (@finsupp.{w u} ι K
                (@no_zero_divisors.to_has_zero.{u} K
                   (@domain.to_no_zero_divisors.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             (@add_monoid.to_add_semigroup.{(max w u)}
                (@finsupp.{w u} ι K
                   (@no_zero_divisors.to_has_zero.{u} K
                      (@domain.to_no_zero_divisors.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                (@add_group.to_add_monoid.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@no_zero_divisors.to_has_zero.{u} K
                         (@domain.to_no_zero_divisors.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                   (@add_comm_group.to_add_group.{(max w u)}
                      (@finsupp.{w u} ι K
                         (@no_zero_divisors.to_has_zero.{u} K
                            (@domain.to_no_zero_divisors.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                      (@finsupp.add_comm_group.{w u} ι K
                         (@ring.to_add_comm_group.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
          x
          y)
       i)
    (@has_add.add.{u} K
       (@add_semigroup.to_has_add.{u} K
          (@add_monoid.to_add_semigroup.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          x
          i)
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          y
          i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    smul := by intros; rw finsupp.smul_apply }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='finsupp.smul_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 1297, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : ring.{u} β] {a : α} {b : β} {v : @finsupp.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))}, @eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))) (@finsupp.has_coe_to_fun.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))) (@has_scalar.smul.{u (max w u)} β (@finsupp.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))) (@finsupp.has_scalar.{w u u} α β β (@ring.to_semiring.{u} β _inst_1) (@semiring.to_add_comm_monoid.{u} β (@ring.to_semiring.{u} β _inst_1)) (@semiring.to_semimodule.{u} β (@ring.to_semiring.{u} β _inst_1))) b v) a) (@has_scalar.smul.{u u} β β (@mul_action.to_has_scalar.{u u} β β (@ring.to_monoid.{u} β _inst_1) (@distrib_mul_action.to_mul_action.{u u} β β (@ring.to_monoid.{u} β _inst_1) (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β _inst_1))) (@semimodule.to_distrib_mul_action.{u u} β β (@ring.to_semiring.{u} β _inst_1) (@semiring.to_add_comm_monoid.{u} β (@ring.to_semiring.{u} β _inst_1)) (@semiring.to_semimodule.{u} β (@ring.to_semiring.{u} β _inst_1))))) b (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))) (@finsupp.has_coe_to_fun.{w u} α β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1)))) v a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='K : Type u,
ι : Type w,
_inst_1 : discrete_field.{u} K,
i : ι
⊢ ∀ (c : K)
  (x :
    @finsupp.{w u} ι K
      (@no_zero_divisors.to_has_zero.{u} K
         (@domain.to_no_zero_divisors.{u} K
            (@division_ring.to_domain.{u} K
               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@has_scalar.smul.{u (max w u)} K
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@mul_action.to_has_scalar.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@ring.to_monoid.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@distrib_mul_action.to_mul_action.{u (max w u)} K
                  (@finsupp.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@ring.to_monoid.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@add_group.to_add_monoid.{(max w u)}
                     (@finsupp.{w u} ι K
                        (@no_zero_divisors.to_has_zero.{u} K
                           (@domain.to_no_zero_divisors.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                     (@add_comm_group.to_add_group.{(max w u)}
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  (@semimodule.to_distrib_mul_action.{u (max w u)} K
                     (@finsupp.{w u} ι K
                        (@no_zero_divisors.to_has_zero.{u} K
                           (@domain.to_no_zero_divisors.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@add_comm_group.to_add_comm_monoid.{(max w u)}
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
                     (@module.to_semimodule.{u (max w u)} K
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.vector_space.{w u u} ι K K _inst_1
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                           (@discrete_field.to_vector_space.{u} K _inst_1))))))
            c
            x)
         i)
      (@has_scalar.smul.{u u} K K
         (@mul_action.to_has_scalar.{u u} K K
            (@ring.to_monoid.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            (@distrib_mul_action.to_mul_action.{u u} K K
               (@ring.to_monoid.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
               (@semimodule.to_distrib_mul_action.{u u} K K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@add_comm_group.to_add_comm_monoid.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@module.to_semimodule.{u u} K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@discrete_field.to_vector_space.{u} K _inst_1)))))
         c
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            x
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
ι : Type w,
_inst_1 : discrete_field.{u} K,
i : ι,
c : K,
x :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_scalar.smul.{u (max w u)} K
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@mul_action.to_has_scalar.{u (max w u)} K
             (@finsupp.{w u} ι K
                (@no_zero_divisors.to_has_zero.{u} K
                   (@domain.to_no_zero_divisors.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             (@ring.to_monoid.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@distrib_mul_action.to_mul_action.{u (max w u)} K
                (@finsupp.{w u} ι K
                   (@no_zero_divisors.to_has_zero.{u} K
                      (@domain.to_no_zero_divisors.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                (@ring.to_monoid.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@add_group.to_add_monoid.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@no_zero_divisors.to_has_zero.{u} K
                         (@domain.to_no_zero_divisors.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                   (@add_comm_group.to_add_group.{(max w u)}
                      (@finsupp.{w u} ι K
                         (@no_zero_divisors.to_has_zero.{u} K
                            (@domain.to_no_zero_divisors.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                      (@finsupp.add_comm_group.{w u} ι K
                         (@ring.to_add_comm_group.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@semimodule.to_distrib_mul_action.{u (max w u)} K
                   (@finsupp.{w u} ι K
                      (@no_zero_divisors.to_has_zero.{u} K
                         (@domain.to_no_zero_divisors.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@add_comm_group.to_add_comm_monoid.{(max w u)}
                      (@finsupp.{w u} ι K
                         (@no_zero_divisors.to_has_zero.{u} K
                            (@domain.to_no_zero_divisors.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                      (@finsupp.add_comm_group.{w u} ι K
                         (@ring.to_add_comm_group.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
                   (@module.to_semimodule.{u (max w u)} K
                      (@finsupp.{w u} ι K
                         (@no_zero_divisors.to_has_zero.{u} K
                            (@domain.to_no_zero_divisors.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      (@finsupp.add_comm_group.{w u} ι K
                         (@ring.to_add_comm_group.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                      (@finsupp.vector_space.{w u u} ι K K _inst_1
                         (@ring.to_add_comm_group.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                         (@discrete_field.to_vector_space.{u} K _inst_1))))))
          c
          x)
       i)
    (@has_scalar.smul.{u u} K K
       (@mul_action.to_has_scalar.{u u} K K
          (@ring.to_monoid.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u u} K K
             (@ring.to_monoid.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
             (@semimodule.to_distrib_mul_action.{u u} K K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                (@module.to_semimodule.{u u} K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@discrete_field.to_vector_space.{u} K _inst_1)))))
       c
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          x
          i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
ι : Type w,
_inst_1 : discrete_field.{u} K,
i : ι
⊢ ∀ (c : K)
  (x :
    @finsupp.{w u} ι K
      (@no_zero_divisors.to_has_zero.{u} K
         (@domain.to_no_zero_divisors.{u} K
            (@division_ring.to_domain.{u} K
               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
         (@has_scalar.smul.{u (max w u)} K
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@mul_action.to_has_scalar.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@ring.to_monoid.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@distrib_mul_action.to_mul_action.{u (max w u)} K
                  (@finsupp.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@ring.to_monoid.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@add_group.to_add_monoid.{(max w u)}
                     (@finsupp.{w u} ι K
                        (@no_zero_divisors.to_has_zero.{u} K
                           (@domain.to_no_zero_divisors.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                     (@add_comm_group.to_add_group.{(max w u)}
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  (@semimodule.to_distrib_mul_action.{u (max w u)} K
                     (@finsupp.{w u} ι K
                        (@no_zero_divisors.to_has_zero.{u} K
                           (@domain.to_no_zero_divisors.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@add_comm_group.to_add_comm_monoid.{(max w u)}
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
                     (@module.to_semimodule.{u (max w u)} K
                        (@finsupp.{w u} ι K
                           (@no_zero_divisors.to_has_zero.{u} K
                              (@domain.to_no_zero_divisors.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                        (@finsupp.add_comm_group.{w u} ι K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                        (@finsupp.vector_space.{w u u} ι K K _inst_1
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                           (@discrete_field.to_vector_space.{u} K _inst_1))))))
            c
            x)
         i)
      (@has_scalar.smul.{u u} K K
         (@mul_action.to_has_scalar.{u u} K K
            (@ring.to_monoid.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            (@distrib_mul_action.to_mul_action.{u u} K K
               (@ring.to_monoid.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
               (@semimodule.to_distrib_mul_action.{u u} K K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@add_comm_group.to_add_comm_monoid.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@module.to_semimodule.{u u} K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@discrete_field.to_vector_space.{u} K _inst_1)))))
         c
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            x
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  include h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  set_option class.instance_max_depth 50</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  def coord_fun (i : ι) : (V →ₗ[K] K) := (eval_finsupp_at i).comp h.repr</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='is_basis.eval_finsupp_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 735, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β : Type v) (γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {K : Type u} {ι : Type w} [_inst_1 : discrete_field.{u} K], ι → @linear_map.{u (max w u) u} K (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@finsupp.vector_space.{w u u} ι K K _inst_1 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@discrete_field.to_vector_space.{u} K _inst_1)) (@discrete_field.to_vector_space.{u} K _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type (max w u)} {δ : Type u} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{(max w u)} γ} {gδ : add_comm_group.{u} δ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u (max w u)} α γ rα gγ} {mδ : @module.{u u} α δ rα gδ}, @linear_map.{u (max w u) u} α γ δ rα gγ gδ mγ mδ → @linear_map.{u v (max w u)} α β γ rα gβ gγ mβ mγ → @linear_map.{u v u} α β δ rα gβ gδ mβ mδ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → @linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Evaluation of finitely supported functions at a fixed point `i`, as a `K`-linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  lemma coord_fun_eq_repr (v : V) (i : ι) : h.coord_fun i v = h.repr v i := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.coord_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 104, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 735, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → ι → @linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → @linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  include de</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  lemma to_dual_swap_eq_to_dual (v w : V) : h.to_dual_flip v w = h.to_dual w v := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual_flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → V → @linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  lemma to_dual_eq_repr (v : V) (i : ι) : (h.to_dual v) (B i) = h.repr v i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 735, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → @linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          v)
       (B i))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          v)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    rw [←coord_fun_eq_repr, ←to_dual_swap_eq_to_dual],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_basis.coord_fun_eq_repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_basis.to_dual_swap_eq_to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v : V) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@linear_map.has_coe_to_fun.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i) v) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@finsupp.has_coe_to_fun.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@linear_map.has_coe_to_fun.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@is_basis.repr.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 h) v) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v w : V), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@linear_map.has_coe_to_fun.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h v) w) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) w) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          v)
       (B i))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          v)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          v)
       (B i))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h (B i))
       v)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    apply congr_fun,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : α → Type u} {f g : Π (x : α), β x}, @eq.{(max (v+1) (u+1))} (Π (x : α), β x) f g → ∀ (a : α), @eq.{u+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h (B i))
       v)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))} (V → K)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h (B i)))
    (λ (v : V),
       @coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
         v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))} (V → K)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h (B i)))
    (λ (v : V),
       @coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
         v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))} (V → K)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i)))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    congr&#x27;,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))} (V → K)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i)))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))}
    (@linear_map.{u v u} K V K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       _inst_3
       (@discrete_field.to_vector_space.{u} K _inst_1))
    (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
    (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    apply h.ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ @eq.{(max (v+1) (u+1))}
    (@linear_map.{u v u} K V K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       _inst_3
       (@discrete_field.to_vector_space.{u} K _inst_1))
    (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
    (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ ∀ (i_1 : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
         (B i_1))
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
         (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    { intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i : ι
⊢ ∀ (i_1 : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
         (B i_1))
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
            _inst_3
            (@discrete_field.to_vector_space.{u} K _inst_1))
         (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
         (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
       (B i_1))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      rw [to_dual_swap_eq_to_dual, to_dual_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_basis.to_dual_swap_eq_to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.to_dual_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v w : V), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@linear_map.has_coe_to_fun.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h v) w) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) w) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (B i)) (B j)) (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.to_dual_flip.{u v w} K V ι _inst_1 _inst_2 _inst_3 de B h (B i))
       (B i_1))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B i_1))
       (B i))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i_1 i) (de i_1 i) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      { split_ifs with hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i_1 i) (de i_1 i) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122        { rwa [hx, coord_fun_eq_repr, repr_eq_single, finsupp.single_apply, if_pos rfl] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.coord_fun_eq_repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.repr_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.single_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 760, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{w+1} ι i_1 i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v : V) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@linear_map.has_coe_to_fun.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i) v) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@finsupp.has_coe_to_fun.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@linear_map.has_coe_to_fun.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@is_basis.repr.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 h) v) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] (hv : @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4) {i : ι}, @eq.{(max (w+1) (u+1))} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@linear_map.has_coe_to_fun.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@is_basis.repr.{w u v} ι R M v _inst_1 _inst_2 _inst_4 hv) (v i)) (@finsupp.single.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) i (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : has_zero.{u} β] {a a&#x27; : α} {b : β}, @eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) (@finsupp.has_coe_to_fun.{w u} α β _inst_1) (@finsupp.single.{w u} α β _inst_1 a b) a&#x27;) (@ite.{u+1} (@eq.{w+1} α a a&#x27;) (classical.prop_decidable (@eq.{w+1} α a a&#x27;)) β b (@has_zero.zero.{u} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {a : α}, @eq.{w+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          (B i))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.single.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          i
          (@has_one.one.{u} K
             (@monoid.to_has_one.{u} K
                (@ring.to_monoid.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@ite.{u+1} (@eq.{w+1} ι i i) (classical.prop_decidable (@eq.{w+1} ι i i)) K
       (@has_one.one.{u} K
          (@monoid.to_has_one.{u} K
             (@ring.to_monoid.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@has_zero.zero.{u} K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : @eq.{w+1} ι i_1 i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123        { rw [coord_fun_eq_repr, repr_eq_single, finsupp.single_apply], symmetry, convert if_neg hx } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_basis.coord_fun_eq_repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.repr_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.single_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 760, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v : V) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@linear_map.has_coe_to_fun.{u v u} K V K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) _inst_3 (@discrete_field.to_vector_space.{u} K _inst_1)) (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i) v) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@finsupp.has_coe_to_fun.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@linear_map.has_coe_to_fun.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@is_basis.repr.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 h) v) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] (hv : @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4) {i : ι}, @eq.{(max (w+1) (u+1))} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@linear_map.has_coe_to_fun.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@is_basis.repr.{w u v} ι R M v _inst_1 _inst_2 _inst_4 hv) (v i)) (@finsupp.single.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) i (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : has_zero.{u} β] {a a&#x27; : α} {b : β}, @eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) (@finsupp.has_coe_to_fun.{w u} α β _inst_1) (@finsupp.single.{w u} α β _inst_1 a b) a&#x27;) (@ite.{u+1} (@eq.{w+1} α a a&#x27;) (classical.prop_decidable (@eq.{w+1} α a a&#x27;)) β b (@has_zero.zero.{u} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{w+1} ι i_1 i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          _inst_3
          (@discrete_field.to_vector_space.{u} K _inst_1))
       (@is_basis.coord_fun.{u v w} K V ι _inst_1 _inst_2 _inst_3 B h i)
       (B i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          (B i_1))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.single.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          i_1
          (@has_one.one.{u} K
             (@monoid.to_has_one.{u} K
                (@ring.to_monoid.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@ite.{u+1} (@eq.{w+1} ι i_1 i) (classical.prop_decidable (@eq.{w+1} ι i_1 i)) K
       (@has_one.one.{u} K
          (@monoid.to_has_one.{u} K
             (@ring.to_monoid.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@has_zero.zero.{u} K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
i i_1 : ι,
hx : not (@eq.{w+1} ι i_1 i)
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i_1 i) (classical.prop_decidable (@eq.{w+1} ι i_1 i)) K
       (@has_one.one.{u} K
          (@monoid.to_has_one.{u} K
             (@ring.to_monoid.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@has_zero.zero.{u} K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  lemma to_dual_inj (v : V) (a : h.to_dual v = 0) : v = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    rw [← mem_bot K, ← h.repr_ker, mem_ker],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='submodule.mem_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='linear_map.mem_ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 926, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] {x : M}, iff (@has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_5) x (@lattice.has_bot.bot.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u v} R M _inst_1 _inst_2 _inst_5))) (@eq.{v+1} M x (@has_zero.zero.{v} M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@linear_map.ker.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@is_basis.repr.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 h)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} {M₂ : Type (max w u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max w u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max w u)} R M₂ _inst_1 _inst_3] {f : @linear_map.{u v (max w u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6} {y : M}, iff (@has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_5) y (@linear_map.ker.{u v (max w u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f)) (@eq.{(max w u)+1} M₂ (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u v (max w u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f y) (@has_zero.zero.{(max w u)} M₂ (@add_monoid.to_has_zero.{(max w u)} M₂ (@add_group.to_add_monoid.{(max w u)} M₂ (@add_comm_group.to_add_group.{(max w u)} M₂ _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       ?m_1)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       ?m_1)
    v
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          ?m_1)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          ?m_1))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @module.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    v
    (@linear_map.ker.{u v (max w u)} K V
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       _inst_3
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@is_basis.repr.{w u v} ι K V B
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @eq.{(max w u)+1}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
       (@linear_map.{u v (max w u)} K V
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@linear_map.has_coe_to_fun.{u v (max w u)} K V
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@is_basis.repr.{w u v} ι K V B
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          h)
       v)
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@add_monoid.to_has_zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_group.to_add_monoid.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_comm_group.to_add_group.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    apply finsupp.ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finsupp.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : has_zero.{u} β] {f g : @finsupp.{w u} α β _inst_1}, (∀ (a : α), @eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) (@finsupp.has_coe_to_fun.{w u} α β _inst_1) f a) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) (@finsupp.has_coe_to_fun.{w u} α β _inst_1) g a)) → @eq.{(max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ @eq.{(max w u)+1}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
       (@linear_map.{u v (max w u)} K V
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@linear_map.has_coe_to_fun.{u v (max w u)} K V
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@is_basis.repr.{w u v} ι K V B
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          h)
       v)
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@add_monoid.to_has_zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_group.to_add_monoid.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_comm_group.to_add_group.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ ∀ (a : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
            (@linear_map.{u v (max w u)} K V
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               _inst_3
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@linear_map.has_coe_to_fun.{u v (max w u)} K V
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               _inst_3
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@is_basis.repr.{w u v} ι K V B
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               _inst_3
               h)
            v)
         a)
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@has_zero.zero.{(max w u)}
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@add_monoid.to_has_zero.{(max w u)}
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@add_group.to_add_monoid.{(max w u)}
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  (@add_comm_group.to_add_group.{(max w u)}
                     (@finsupp.{w u} ι K
                        (@mul_zero_class.to_has_zero.{u} K
                           (@semiring.to_mul_zero_class.{u} K
                              (@ring.to_semiring.{u} K
                                 (@domain.to_ring.{u} K
                                    (@division_ring.to_domain.{u} K
                                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                     (@finsupp.add_comm_group.{w u} ι K
                        (@ring.to_add_comm_group.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    intro b,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)))))
⊢ ∀ (a : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
            (@linear_map.{u v (max w u)} K V
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               _inst_3
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@linear_map.has_coe_to_fun.{u v (max w u)} K V
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               _inst_3
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@is_basis.repr.{w u v} ι K V B
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               _inst_3
               h)
            v)
         a)
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@has_zero.zero.{(max w u)}
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@add_monoid.to_has_zero.{(max w u)}
               (@finsupp.{w u} ι K
                  (@mul_zero_class.to_has_zero.{u} K
                     (@semiring.to_mul_zero_class.{u} K
                        (@ring.to_semiring.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
               (@add_group.to_add_monoid.{(max w u)}
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  (@add_comm_group.to_add_group.{(max w u)}
                     (@finsupp.{w u} ι K
                        (@mul_zero_class.to_has_zero.{u} K
                           (@semiring.to_mul_zero_class.{u} K
                              (@ring.to_semiring.{u} K
                                 (@domain.to_ring.{u} K
                                    (@division_ring.to_domain.{u} K
                                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                     (@finsupp.add_comm_group.{w u} ι K
                        (@ring.to_add_comm_group.{u} K
                           (@domain.to_ring.{u} K
                              (@division_ring.to_domain.{u} K
                                 (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          v)
       b)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_monoid.to_has_zero.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_group.to_add_monoid.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@add_comm_group.to_add_group.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@mul_zero_class.to_has_zero.{u} K
                         (@semiring.to_mul_zero_class.{u} K
                            (@ring.to_semiring.{u} K
                               (@domain.to_ring.{u} K
                                  (@division_ring.to_domain.{u} K
                                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                   (@finsupp.add_comm_group.{w u} ι K
                      (@ring.to_add_comm_group.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
       b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    rw [←to_dual_eq_repr _ _ _, a],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_basis.to_dual_eq_repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v : V) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) v) (B i)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@finsupp.has_coe_to_fun.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@linear_map.has_coe_to_fun.{u v (max w u)} K V (@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@finsupp.add_comm_group.{w u} ι K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) _inst_3 (@finsupp.module.{w u u} ι K K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (@ring.to_module.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))) (@is_basis.repr.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 h) v) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) v) (@has_zero.zero.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_monoid.to_has_zero.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_group.to_add_monoid.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_comm_group.to_add_group.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          v)
       b)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_monoid.to_has_zero.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_group.to_add_monoid.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@add_comm_group.to_add_group.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@mul_zero_class.to_has_zero.{u} K
                         (@semiring.to_mul_zero_class.{u} K
                            (@ring.to_semiring.{u} K
                               (@domain.to_ring.{u} K
                                  (@division_ring.to_domain.{u} K
                                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                   (@finsupp.add_comm_group.{w u} ι K
                      (@ring.to_add_comm_group.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
       b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), ?m_1 a b) B h)
          v)
       (B b))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_monoid.to_has_zero.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_group.to_add_monoid.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@add_comm_group.to_add_group.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@mul_zero_class.to_has_zero.{u} K
                         (@semiring.to_mul_zero_class.{u} K
                            (@ring.to_semiring.{u} K
                               (@domain.to_ring.{u} K
                                  (@division_ring.to_domain.{u} K
                                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                   (@finsupp.add_comm_group.{w u} ι K
                      (@ring.to_add_comm_group.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
       b)

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ decidable_eq.{w+1} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)))))
       (B b))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_monoid.to_has_zero.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_group.to_add_monoid.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@add_comm_group.to_add_group.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@mul_zero_class.to_has_zero.{u} K
                         (@semiring.to_mul_zero_class.{u} K
                            (@ring.to_semiring.{u} K
                               (@domain.to_ring.{u} K
                                  (@division_ring.to_domain.{u} K
                                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                   (@finsupp.add_comm_group.{w u} ι K
                      (@ring.to_add_comm_group.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
       b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
v : V,
a :
  @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))))),
b : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)))))
       (B b))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@add_monoid.to_has_zero.{(max w u)}
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@add_group.to_add_monoid.{(max w u)}
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                (@add_comm_group.to_add_group.{(max w u)}
                   (@finsupp.{w u} ι K
                      (@mul_zero_class.to_has_zero.{u} K
                         (@semiring.to_mul_zero_class.{u} K
                            (@ring.to_semiring.{u} K
                               (@domain.to_ring.{u} K
                                  (@division_ring.to_domain.{u} K
                                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                   (@finsupp.add_comm_group.{w u} ι K
                      (@ring.to_add_comm_group.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))))
       b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  theorem to_dual_ker : h.to_dual.ker = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u v} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  ker_eq_bot&#x27;.mpr h.to_dual_inj</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.ker_eq_bot&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 959, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3] {f : @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6}, iff (@eq.{v+1} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@linear_map.ker.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_bot.bot.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u v} R M _inst_1 _inst_2 _inst_5))) (∀ (m : M), @eq.{(max v u)+1} M₂ (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f m) (@has_zero.zero.{(max v u)} M₂ (@add_monoid.to_has_zero.{(max v u)} M₂ (@add_group.to_add_monoid.{(max v u)} M₂ (@add_comm_group.to_add_group.{(max v u)} M₂ _inst_3)))) → @eq.{v+1} M m (@has_zero.zero.{v} M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (v : V), @eq.{(max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) v) (@has_zero.zero.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_monoid.to_has_zero.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_group.to_add_monoid.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@add_comm_group.to_add_group.{(max v u)} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))))) → @eq.{v+1} V v (@has_zero.zero.{v} V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  theorem to_dual_range [fin : fintype ι] : h.to_dual.range = ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 885, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u (max v u)} R M₂ _inst_1 _inst_3 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max v u)) [c : lattice.has_top.{(max v u)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The range of a linear map `f : M → M₂` is a submodule of `M₂`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    rw eq_top_iff&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='submodule.eq_top_iff&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 430, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{(max v u)} M] [_inst_5 : @module.{u (max v u)} R M _inst_1 _inst_2] {p : @submodule.{u (max v u)} R M _inst_1 _inst_2 _inst_5}, iff (@eq.{(max v u)+1} (@submodule.{u (max v u)} R M _inst_1 _inst_2 _inst_5) p (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_top.{u (max v u)} R M _inst_1 _inst_2 _inst_5))) (∀ (x : M), @has_mem.mem.{(max v u) (max v u)} M (@submodule.{u (max v u)} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u (max v u)} R M _inst_1 _inst_2 _inst_5) x p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι
⊢ ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @has_mem.mem.{(max v u) (max v u)}
      (@module.dual.{u v} K V
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         _inst_2
         _inst_3)
      (@submodule.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      (@submodule.has_mem.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      x
      (@linear_map.range.{u v (max v u)} K V
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         _inst_3
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
         (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    intro f,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι
⊢ ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @has_mem.mem.{(max v u) (max v u)}
      (@module.dual.{u v} K V
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         _inst_2
         _inst_3)
      (@submodule.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      (@submodule.has_mem.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      x
      (@linear_map.range.{u v (max v u)} K V
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         _inst_3
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
         (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ @has_mem.mem.{(max v u) (max v u)}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@submodule.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    f
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    rw linear_map.mem_range,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_map.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 889, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3] {f : @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6} {x : M₂}, iff (@has_mem.mem.{(max v u) (max v u)} M₂ (@submodule.{u (max v u)} R M₂ _inst_1 _inst_3 _inst_6) (@submodule.has_mem.{u (max v u)} R M₂ _inst_1 _inst_3 _inst_6) x (@linear_map.range.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f)) (@Exists.{v+1} M (λ (y : M), @eq.{(max v u)+1} M₂ (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f y) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ @has_mem.mem.{(max v u) (max v u)}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@submodule.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    f
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ @Exists.{v+1} V
    (λ (y : V),
       @eq.{(max v u)+1}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            y)
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    let lin_comb : ι →₀ K := finsupp.on_finset fin.elems (λ i, f.to_fun (B i)) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finsupp.on_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type u} [_inst_1 : has_zero.{u} β] (s : finset.{w} α) (f : α → β), (∀ (a : α), @ne.{u+1} β (f a) (@has_zero.zero.{u} β _inst_1) → @has_mem.mem.{w w} α (finset.{w} α) (@finset.has_mem.{w} α) a s) → @finsupp.{w u} α β _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fintype.{w} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `on_finset s f hf` is the finsupp function representing `f` restricted to the set `s`.
The function needs to be 0 outside of `s`. Use this when the set needs filtered anyway, otherwise
often better set representation is available.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ @Exists.{v+1} V
    (λ (y : V),
       @eq.{(max v u)+1}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            y)
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ @Exists.{v+1} V
    (λ (y : V),
       @eq.{(max v u)+1}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            y)
         f)

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ ∀ (a : ι),
    @ne.{u+1} K
      (@linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B a))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    { use finsupp.total ι V K B lin_comb,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finsupp.total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lin_comb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 296, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type w) (M : Type v) (R : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M _inst_1 _inst_2], (α → M) → @linear_map.{u (max w u) v} R (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Interprets (l : α →₀ R) as linear combination of the elements in the family (v : α → M) and
   evaluates this linear combination.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ @Exists.{v+1} V
    (λ (y : V),
       @eq.{(max v u)+1}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            y)
         f)

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ ∀ (a : ι),
    @ne.{u+1} K
      (@linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B a))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ @Exists.{v+1} V
    (λ (y : V),
       @eq.{(max v u)+1}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            y)
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ @eq.{(max v u)+1}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
          (@linear_map.{u (max w u) v} K
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_2
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3)
          (@linear_map.has_coe_to_fun.{u (max w u) v} K
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_2
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3)
          (@finsupp.total.{w v u} ι V K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             B)
          lin_comb))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      apply h.ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ @eq.{(max v u)+1}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
       (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
          (@linear_map.{u (max w u) v} K
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_2
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3)
          (@linear_map.has_coe_to_fun.{u (max w u) v} K
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_2
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3)
          (@finsupp.total.{w v u} ι V K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             B)
          lin_comb))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ ∀ (i : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
               (@linear_map.{u (max w u) v} K
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  V
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@finsupp.add_comm_group.{w u} ι K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_2
                  (@finsupp.module.{w u u} ι K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@ring.to_module.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_3)
               (@linear_map.has_coe_to_fun.{u (max w u) v} K
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  V
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@finsupp.add_comm_group.{w u} ι K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_2
                  (@finsupp.module.{w u u} ι K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@ring.to_module.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_3)
               (@finsupp.total.{w v u} ι V K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  _inst_2
                  _inst_3
                  B)
               lin_comb))
         (B i))
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         f
         (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146      { intros i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1
⊢ ∀ (i : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
            (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
               (@linear_map.{u (max w u) v} K
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  V
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@finsupp.add_comm_group.{w u} ι K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_2
                  (@finsupp.module.{w u u} ι K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@ring.to_module.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_3)
               (@linear_map.has_coe_to_fun.{u (max w u) v} K
                  (@finsupp.{w u} ι K
                     (@mul_zero_class.to_has_zero.{u} K
                        (@semiring.to_mul_zero_class.{u} K
                           (@ring.to_semiring.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                  V
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@finsupp.add_comm_group.{w u} ι K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_2
                  (@finsupp.module.{w u u} ι K K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                     (@ring.to_module.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  _inst_3)
               (@finsupp.total.{w v u} ι V K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  _inst_2
                  _inst_3
                  B)
               lin_comb))
         (B i))
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@linear_map.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u v u} K V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            _inst_3
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         f
         (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
             (@linear_map.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@linear_map.has_coe_to_fun.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@finsupp.total.{w v u} ι V K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3
                B)
             lin_comb))
       (B i))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147        rw [h.to_dual_eq_repr _ i, repr_total h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.repr_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 752, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] (hv : @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4) (x : @finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))), @has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@submodule.{u (max w u)} R (@finsupp.{w u} ι R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} ι R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) x (@finsupp.supported.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1) (@set.univ.{w} ι)) → @eq.{(max (w+1) (u+1))} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))} (@linear_map.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@linear_map.has_coe_to_fun.{u v (max w u)} R M (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@is_basis.repr.{w u v} ι R M v _inst_1 _inst_2 _inst_4 hv) (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))} (@linear_map.{u (max w u) v} R (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_4) (@linear_map.has_coe_to_fun.{u (max w u) v} R (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_4) (@finsupp.total.{w v u} ι M R _inst_1 _inst_2 _inst_4 v) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
             (@linear_map.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@linear_map.has_coe_to_fun.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@finsupp.total.{w v u} ι V K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3
                B)
             lin_comb))
       (B i))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@coe_fn.{(max (v+1) ((max w u)+1)) (max (v+1) ((max w u)+1))}
          (@linear_map.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u v (max w u)} K V
             (@finsupp.{w u} ι K
                (@mul_zero_class.to_has_zero.{u} K
                   (@semiring.to_mul_zero_class.{u} K
                      (@ring.to_semiring.{u} K
                         (@domain.to_ring.{u} K
                            (@division_ring.to_domain.{u} K
                               (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@finsupp.add_comm_group.{w u} ι K
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
             _inst_3
             (@finsupp.module.{w u u} ι K K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@ring.to_add_comm_group.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                (@ring.to_module.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
          (@is_basis.repr.{w u v} ι K V B
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3
             h)
          (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
             (@linear_map.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@linear_map.has_coe_to_fun.{u (max w u) v} K
                (@finsupp.{w u} ι K
                   (@mul_zero_class.to_has_zero.{u} K
                      (@semiring.to_mul_zero_class.{u} K
                         (@ring.to_semiring.{u} K
                            (@domain.to_ring.{u} K
                               (@division_ring.to_domain.{u} K
                                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                (@finsupp.add_comm_group.{w u} ι K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_2
                (@finsupp.module.{w u u} ι K K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                   (@ring.to_module.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                _inst_3)
             (@finsupp.total.{w v u} ι V K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3
                B)
             lin_comb))
       i)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       lin_comb
       i)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    lin_comb
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@set.univ.{w} ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148        { simpa },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       lin_comb
       i)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    lin_comb
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@set.univ.{w} ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       lin_comb
       i)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       f
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    lin_comb
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@set.univ.{w} ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149        { rw [finsupp.mem_supported],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='finsupp.mem_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {M : Type u} (R : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : @module.{u u} R M _inst_1 _inst_2] {s : set.{w} α} (p : @finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))), iff (@has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{w u} α M _inst_2) (@finsupp.module.{w u u} α M R _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{w u} α M _inst_2) (@finsupp.module.{w u u} α M R _inst_1 _inst_2 _inst_3)) p (@finsupp.supported.{w u u} α M R _inst_1 _inst_2 _inst_3 s)) (@has_subset.subset.{w} (set.{w} α) (@set.has_subset.{w} α) (@coe.{w+1 w+1} (finset.{w} α) (set.{w} α) (@lift_base.{w+1 w+1} (finset.{w} α) (set.{w} α) (@finset.has_lift.{w} α)) (@finsupp.support.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2))) p)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    lin_comb
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@set.univ.{w} ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_subset.subset.{w} (set.{w} ι) (@set.has_subset.{w} ι)
    (@coe.{w+1 w+1} (finset.{w} ι) (set.{w} ι)
       (@lift_base.{w+1 w+1} (finset.{w} ι) (set.{w} ι) (@finset.has_lift.{w} ι))
       (@finsupp.support.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          lin_comb))
    (@set.univ.{w} ι)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150          exact λ _ _, set.mem_univ _ } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} (x : α), @has_mem.mem.{w w} α (set.{w} α) (@set.has_mem.{w} α) x (@set.univ.{w} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
lin_comb : @finsupp.{w u} ι K
  (@no_zero_divisors.to_has_zero.{u} K
     (@domain.to_no_zero_divisors.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) :=
  @finsupp.on_finset.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
    (@fintype.elems.{w} ι fin)
    (λ (i : ι),
       @linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B i))
    ?m_1,
i : ι
⊢ @has_subset.subset.{w} (set.{w} ι) (@set.has_subset.{w} ι)
    (@coe.{w+1 w+1} (finset.{w} ι) (set.{w} ι)
       (@lift_base.{w+1 w+1} (finset.{w} ι) (set.{w} ι) (@finset.has_lift.{w} ι))
       (@finsupp.support.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          lin_comb))
    (@set.univ.{w} ι)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ ∀ (a : ι),
    @ne.{u+1} K
      (@linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B a))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    { intros a _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3
⊢ ∀ (a : ι),
    @ne.{u+1} K
      (@linear_map.to_fun.{u v u} K V K
         (@comm_ring.to_ring.{u} K
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
         _inst_2
         (@ring.to_add_comm_group.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         _inst_3
         (@ring.to_module.{u} K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
         f
         (B a))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
a : ι,
a_1 :
  @ne.{u+1} K
    (@linear_map.to_fun.{u v u} K V K
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@ring.to_add_comm_group.{u} K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
       _inst_3
       (@ring.to_module.{u} K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
       f
       (B a))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
⊢ @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      apply fin.complete }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
fin : fintype.{w} ι,
f :
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
a : ι,
a_1 :
  @ne.{u+1} K
    (@linear_map.to_fun.{u v u} K V K
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@ring.to_add_comm_group.{u} K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
       _inst_3
       (@ring.to_module.{u} K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
       f
       (B a))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
⊢ @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a (@fintype.elems.{w} ι fin)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  /-- Maps a basis for `V` to a basis for the dual space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  def dual_basis : ι → dual K V := λ i, h.to_dual (B i)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  theorem dual_lin_independent : linear_independent K h.dual_basis :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='linear_independent'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.dual_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Linearly independent family of vectors'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Maps a basis for `V` to a basis for the dual space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @linear_independent.{w u (max v u)} ι K
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    (@module.dual.add_comm_group_1.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    apply linear_independent.image h.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_independent.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 562, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type (max v u)} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M&#x27; _inst_1 _inst_3], @linear_independent.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → ∀ {f : @linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5}, @disjoint.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_4) (@lattice.semilattice_inf_bot_of_bounded_lattice.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_4) (@lattice.complete_lattice.to_bounded_lattice.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_4) (@submodule.lattice.complete_lattice.{u v} R M _inst_1 _inst_2 _inst_4))) (@submodule.span.{u v} R M _inst_1 _inst_2 _inst_4 (@set.range.{v w+1} M ι v)) (@linear_map.ker.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) → @linear_independent.{w u (max v u)} ι R M&#x27; (@function.comp.{w+1 v+1 (max v u)+1} ι M M&#x27; (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f) v) _inst_1 _inst_3 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @linear_independent.{w u (max v u)} ι K
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    (@module.dual.add_comm_group_1.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @disjoint.{v}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.complete_lattice.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι B))
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), (λ (a b : ι), de a b) a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    rw to_dual_ker,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_basis.to_dual_ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3), @eq.{v+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@linear_map.ker.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @disjoint.{v}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.complete_lattice.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι B))
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), (λ (a b : ι), de a b) a b) B h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @disjoint.{v}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.complete_lattice.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι B))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    exact disjoint_bot_right</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='disjoint_bot_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 773, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : lattice.semilattice_inf_bot.{v} α] {a : α}, @disjoint.{v} α _inst_1 a (@lattice.has_bot.bot.{v} α (@lattice.order_bot.to_has_bot.{v} α (@lattice.semilattice_inf_bot.to_order_bot.{v} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @disjoint.{v}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.complete_lattice.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι B))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  /-- A vector space is linearly equivalent to its dual space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  def to_dual_equiv [fintype ι] : V ≃ₗ[K] (dual K V) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type (max v u)) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type (max v u)) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  linear_equiv.of_bijective h.to_dual h.to_dual_ker h.to_dual_range</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv.of_bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual_ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1348, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 138, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type w} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{w} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u w} R M₂ _inst_1 _inst_3] (f : @linear_map.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6), @eq.{v+1} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@linear_map.ker.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_bot.bot.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u v} R M _inst_1 _inst_2 _inst_5)) → @eq.{w+1} (@submodule.{u w} R M₂ _inst_1 _inst_3 _inst_6) (@linear_map.range.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_top.top.{w} (@submodule.{u w} R M₂ _inst_1 _inst_3 _inst_6) (@submodule.lattice.has_top.{u w} R M₂ _inst_1 _inst_3 _inst_6)) → @linear_equiv.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3), @eq.{v+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@linear_map.ker.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) [fin : fintype.{w} ι], @eq.{(max v u)+1} (@submodule.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.range.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)) (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@submodule.lattice.has_top.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A bijective linear map is a linear equivalence. Here, bijectivity is described by saying that
the kernel of `f` is `{0}` and the range is the universal set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  theorem dual_basis_is_basis [fintype ι] : is_basis K h.dual_basis :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.dual_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Maps a basis for `V` to a basis for the dual space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  h.to_dual_equiv.is_basis h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv.is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 861, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → Π [_inst_4 : fintype.{w} ι], @linear_equiv.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type (max v u)} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M&#x27; _inst_1 _inst_3], @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → ∀ (f : @linear_equiv.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), @is_basis.{w u (max v u)} ι R M&#x27; (@function.comp.{w+1 v+1 (max v u)+1} ι M M&#x27; (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_equiv.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@coe_fn_trans.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_equiv.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@coe_base_aux.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_equiv.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_equiv.has_coe.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) f) v) _inst_1 _inst_3 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A vector space is linearly equivalent to its dual space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  @[simp] lemma to_dual_to_dual [fintype ι] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    (h.dual_basis_is_basis.to_dual).comp h.to_dual = eval K V :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.dual_basis_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_basis.to_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.dual.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) [_inst_4 : fintype.{w} ι], @is_basis.{w u (max v u)} ι K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type (max v u)} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{(max v u)} V] [_inst_3 : @vector_space.{u (max v u)} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u (max v u)} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u (max v u) (max v u)} K V (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ δ : Type (max v u)} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{(max v u)} γ} {gδ : add_comm_group.{(max v u)} δ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u (max v u)} α γ rα gγ} {mδ : @module.{u (max v u)} α δ rα gδ}, @linear_map.{u (max v u) (max v u)} α γ δ rα gγ gδ mγ mδ → @linear_map.{u v (max v u)} α β γ rα gβ gγ mβ mγ → @linear_map.{u v (max v u)} α β δ rα gβ gδ mβ mδ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → @linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @linear_map.{u_1 u_2 (max u_2 u_1)} R M (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and
`vector_space.eval_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ @eq.{(max (v+1) ((max v u)+1))}
    (@linear_map.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       _inst_3
       (@is_basis.dual.vector_space.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
    (@linear_map.comp.{u v (max v u) (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.dual.vector_space.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u (max v u) w} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          ι
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (λ (a b : ι), de a b)
          (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
    (@module.dual.eval.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    apply @is_basis.ext _ _ _ _ _ _ _ _ _ _ _ _ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_basis.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 772, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {M&#x27; : Type (max v u)} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M&#x27;] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M&#x27; _inst_1 _inst_3] {f g : @linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5}, @is_basis.{w u v} ι R M v _inst_1 _inst_2 _inst_4 → (∀ (i : ι), @eq.{(max v u)+1} M&#x27; (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f (v i)) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) g (v i))) → @eq.{(max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ @eq.{(max (v+1) ((max v u)+1))}
    (@linear_map.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       _inst_3
       (@is_basis.dual.vector_space.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
    (@linear_map.comp.{u v (max v u) (max v u)} K V
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       _inst_3
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@is_basis.dual.vector_space.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u (max v u) w} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          ι
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (λ (a b : ι), de a b)
          (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
       (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
    (@module.dual.eval.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ ∀ (i : ι),
    @eq.{(max v u)+1}
      (@module.dual.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.comp.{u v (max v u) (max v u)} K V
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u (max v u) w} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               ι
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
               (λ (a b : ι), de a b)
               (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
               (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                  _inst_4))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
         (B i))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@module.dual.eval.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    intros i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ ∀ (i : ι),
    @eq.{(max v u)+1}
      (@module.dual.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.comp.{u v (max v u) (max v u)} K V
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@is_basis.to_dual.{u (max v u) w} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               ι
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
               (λ (a b : ι), de a b)
               (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
               (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                  _inst_4))
            (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
         (B i))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
            _inst_3
            (@is_basis.dual.vector_space.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               _inst_1
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
         (@module.dual.eval.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i : ι
⊢ @eq.{(max v u)+1}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.comp.{u v (max v u) (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u (max v u) w} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             ι
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (λ (a b : ι), de a b)
             (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
       (B i))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    apply @is_basis.ext _ _ _ _ _ _ _ _ _ _ _ _ h.dual_basis_is_basis,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_basis.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 772, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type (max v u)} {M&#x27; : Type u} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{(max v u)} M] [_inst_3 : add_comm_group.{u} M&#x27;] [_inst_4 : @module.{u (max v u)} R M _inst_1 _inst_2] [_inst_5 : @module.{u u} R M&#x27; _inst_1 _inst_3] {f g : @linear_map.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5}, @is_basis.{w u (max v u)} ι R M v _inst_1 _inst_2 _inst_4 → (∀ (i : ι), @eq.{u+1} M&#x27; (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f (v i)) (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) g (v i))) → @eq.{(max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i : ι
⊢ @eq.{(max v u)+1}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.comp.{u v (max v u) (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u (max v u) w} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             ι
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (λ (a b : ι), de a b)
             (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
       (B i))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i : ι
⊢ ∀ (i_1 : ι),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.comp.{u v (max v u) (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@is_basis.to_dual.{u (max v u) w} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  ι
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                  (λ (a b : ι), de a b)
                  (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                  (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                     _inst_4))
               (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
            (B i))
         (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h i_1))
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (B i))
         (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    intros j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i : ι
⊢ ∀ (i_1 : ι),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.comp.{u v (max v u) (max v u)} K V
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@is_basis.to_dual.{u (max v u) w} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  ι
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                  (λ (a b : ι), de a b)
                  (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                  (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                     _inst_4))
               (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
            (B i))
         (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h i_1))
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
               _inst_3
               (@is_basis.dual.vector_space.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  _inst_1
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (B i))
         (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@module.dual.eval.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    dunfold eval,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@module.dual.eval.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.flip.{u (max v u) v u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             V
             K
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             _inst_2
             (@ring.to_add_comm_group.{u} K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             _inst_3
             (@ring.to_module.{u} K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
             (@linear_map.id.{u (max v u)} K
                (@linear_map.{u v u} K V K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                (@linear_map.add_comm_group.{u v u} K V K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
                (@linear_map.module.{u v u} K V K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    rw [linear_map.flip_apply, linear_map.id_apply, linear_map.comp_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='linear_map.flip_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.id_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.comp_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/tensor_product.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 207, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : comm_ring.{u} R] {M : Type (max v u)} {N : Type v} {P : Type u} [_inst_2 : add_comm_group.{(max v u)} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : add_comm_group.{u} P] [_inst_6 : @module.{u (max v u)} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_7 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [_inst_8 : @module.{u u} R P (@comm_ring.to_ring.{u} R _inst_1) _inst_4] (f : @linear_map.{u (max v u) (max v u)} R M (@linear_map.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u v u} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (m : M) (n : N), @eq.{u+1} P (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@linear_map.has_coe_to_fun.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R N (@linear_map.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u (max v u) u} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)) (@linear_map.has_coe_to_fun.{u v (max v u)} R N (@linear_map.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) (@comm_ring.to_ring.{u} R _inst_1) _inst_3 (@linear_map.add_comm_group.{u (max v u) u} R M P (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 _inst_6 _inst_8) _inst_7 (@linear_map.module.{u (max v u) u} R M P _inst_1 _inst_2 _inst_4 _inst_6 _inst_8)) (@linear_map.flip.{u (max v u) v u} R _inst_1 M N P _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f) n) m) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@linear_map.has_coe_to_fun.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@coe_fn.{(max v u)+1 (max v u)+1} (@linear_map.{u (max v u) (max v u)} R M (@linear_map.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u v u} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} R M (@linear_map.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v u} R N P (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_4 _inst_7 _inst_8) _inst_6 (@linear_map.module.{u v u} R N P _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) f m) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type (max v u)} [rα : ring.{u} α] [gβ : add_comm_group.{(max v u)} β] [mβ : @module.{u (max v u)} α β rα gβ] (x : β), @eq.{(max v u)+1} β (@coe_fn.{(max v u)+1 (max v u)+1} (@linear_map.{u (max v u) (max v u)} α β β rα gβ gβ mβ mβ) (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} α β β rα gβ gβ mβ mβ) (@linear_map.id.{u (max v u)} α β rα gβ mβ) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ δ : Type (max v u)} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{(max v u)} γ} {gδ : add_comm_group.{(max v u)} δ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u (max v u)} α γ rα gγ} {mδ : @module.{u (max v u)} α δ rα gδ} (f : @linear_map.{u (max v u) (max v u)} α γ δ rα gγ gδ mγ mδ) (g : @linear_map.{u v (max v u)} α β γ rα gβ gγ mβ mγ) (x : β), @eq.{(max v u)+1} δ (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} α β δ rα gβ gδ mβ mδ) (@linear_map.has_coe_to_fun.{u v (max v u)} α β δ rα gβ gδ mβ mδ) (@linear_map.comp.{u v (max v u) (max v u)} α β γ δ rα gβ gγ gδ mβ mγ mδ f g) x) (@coe_fn.{(max v u)+1 (max v u)+1} (@linear_map.{u (max v u) (max v u)} α γ δ rα gγ gδ mγ mδ) (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} α γ δ rα gγ gδ mγ mδ) f (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{u v (max v u)} α β γ rα gβ gγ mβ mγ) g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.flip.{u (max v u) v u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             V
             K
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             _inst_2
             (@ring.to_add_comm_group.{u} K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             _inst_3
             (@ring.to_module.{u} K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
             (@linear_map.id.{u (max v u)} K
                (@linear_map.{u v u} K V K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                (@linear_map.add_comm_group.{u v u} K V K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
                (@linear_map.module.{u v u} K V K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   (@ring.to_add_comm_group.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                   _inst_3
                   (@ring.to_module.{u} K
                      (@comm_ring.to_ring.{u} K
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max v u)+1 (max v u)+1}
          (@linear_map.{u (max v u) (max v u)} K
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))
          (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} K
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))
          (@linear_map.id.{u (max v u)} K
             (@linear_map.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
             (@linear_map.add_comm_group.{u v u} K V K
                (@comm_ring.to_ring.{u} K
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
             (@linear_map.module.{u v u} K V K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
                _inst_3
                (@ring.to_module.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))
          (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.comp.{u v (max v u) (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u (max v u) w} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                ι
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
                (λ (a b : ι), de a b)
                (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
                (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h
                   _inst_4))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h))
          (B i))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max v u)+1 (max v u)+1}
          (@linear_map.{u (max v u) (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@is_basis.to_dual.{u (max v u) w} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             ι
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (λ (a b : ι), de a b)
             (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
          (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
             (@linear_map.{u v (max v u)} K V
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_3
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@linear_map.has_coe_to_fun.{u v (max v u)} K V
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_3
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (B i)))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    apply eq.trans (to_dual_apply h.dual_basis_is_basis i j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.to_dual_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b c : α}, @eq.{u+1} α a b → @eq.{u+1} α b c → @eq.{u+1} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} {V : Type (max v u)} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{(max v u)} V] [_inst_3 : @vector_space.{u (max v u)} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u (max v u)} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (i j : ι), @eq.{u+1} K (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max v u)+1 (max v u)+1} (@linear_map.{u (max v u) (max v u)} K V (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} K V (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u (max v u) w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (B i)) (B j)) (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max v u)+1 (max v u)+1}
          (@linear_map.{u (max v u) (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@linear_map.has_coe_to_fun.{u (max v u) (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.add_comm_group_1.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (@is_basis.dual.vector_space.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_1
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
          (@is_basis.to_dual.{u (max v u) w} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             ι
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (λ (a b : ι), de a b)
             (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (@is_basis.dual_basis_is_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h _inst_4))
          (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
             (@linear_map.{u v (max v u)} K V
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_3
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@linear_map.has_coe_to_fun.{u v (max v u)} K V
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                _inst_3
                (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
             (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
             (B i)))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    { dunfold dual_basis,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h j)
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B j))
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      rw to_dual_apply,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_basis.to_dual_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (B i)) (B j)) (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)
          (B j))
       (B i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@ite.{u+1} (@eq.{w+1} ι j i) (de j i) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184      split_ifs with h₁ h₂; try {refl},</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι
⊢ @eq.{u+1} K
    (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@ite.{u+1} (@eq.{w+1} ι j i) (de j i) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : @eq.{w+1} ι i j,
h₂ : @eq.{w+1} ι j i
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : @eq.{w+1} ι i j,
h₂ : not (@eq.{w+1} ι j i)
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185      { exfalso, apply h₂ h₁.symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{w+1} ι j i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{w+1} ι i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : @eq.{w+1} ι i j,
h₂ : not (@eq.{w+1} ι j i)
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))

K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : @eq.{w+1} ι i j,
h₂ : not (@eq.{w+1} ι j i)
⊢ @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : @eq.{w+1} ι i j,
h₂ : not (@eq.{w+1} ι j i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186      { exfalso, apply ne.symm h₁ (by assumption) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {a b : α}, @ne.{w+1} α a b → @ne.{w+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{w+1} ι i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ @eq.{u+1} K
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ @eq.{w+1} ι j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
i j : ι,
h₁ : not (@eq.{w+1} ι i j),
h_1 : @eq.{w+1} ι j i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  theorem dual_dim_eq [fintype ι] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    cardinal.lift.{v u} (dim K V) = dim K (dual K V) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type ((max v u)+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    have :=  linear_equiv.dim_eq_lift  h.to_dual_equiv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='linear_equiv.dim_eq_lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 390, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {E : Type (max v u)} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [_inst_4 : add_comm_group.{(max v u)} E] [_inst_5 : @vector_space.{u (max v u)} K E _inst_1 _inst_4], @linear_equiv.{u v (max v u)} K V E (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5 → @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v (max v u)} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)) (cardinal.lift.{(max v u) v} (@vector_space.dim.{u (max v u)} K E _inst_1 _inst_4 _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Version of linear_equiv.dim_eq without universe constraints.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A vector space is linearly equivalent to its dual space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v (max v u)} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    simp only [cardinal.lift_umax] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='cardinal.lift_umax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 454, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (?l_1+2) ((max ?l_1 ?l_2)+2))} (cardinal.{?l_1} → cardinal.{(max ?l_1 ?l_2)}) cardinal.lift.{?l_1 (max ?l_1 ?l_2)} cardinal.lift.{?l_1 ?l_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v (max v u)} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    rw [this, ← cardinal.lift_umax],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cardinal.lift_umax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 454, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)) (cardinal.lift.{(max v u) v} (@vector_space.dim.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v u)+2} (cardinal.{(max v u)} → cardinal.{(max v u)}) cardinal.lift.{(max v u) (max v u)} cardinal.lift.{(max v u) v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{(max v u) (max v u)}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    apply cardinal.lift_id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.lift_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 461, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : cardinal.{(max v u)}), @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{(max v u) (max v u)} a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
de : decidable_eq.{w+1} ι,
B : ι → V,
h :
  @is_basis.{w u v} ι K V B
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
_inst_4 : fintype.{w} ι,
this :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{(max v u) v}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
⊢ @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{(max v u) (max v u)}
       (@vector_space.dim.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  end is_basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  namespace vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  variables {K : Type u} {V : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  open module module.dual submodule linear_map cardinal is_basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  theorem eval_ker : (eval K V).ker = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='module.dual.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @linear_map.{u_1 u_2 (max u_2 u_1)} R M (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u v} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and
`vector_space.eval_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    haveI := classical.dec_eq K,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u), decidable_eq.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    haveI := classical.dec_eq V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v), decidable_eq.{v+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    haveI := classical.dec_eq (dual K V),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type (max v u)), decidable_eq.{(max (v+1) (u+1))} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    rw ker_eq_bot&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_map.ker_eq_bot&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 959, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3] {f : @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6}, iff (@eq.{v+1} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@linear_map.ker.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_bot.bot.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u v} R M _inst_1 _inst_2 _inst_5))) (∀ (m : M), @eq.{(max v u)+1} M₂ (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f m) (@has_zero.zero.{(max v u)} M₂ (@add_monoid.to_has_zero.{(max v u)} M₂ (@add_group.to_add_monoid.{(max v u)} M₂ (@add_comm_group.to_add_group.{(max v u)} M₂ _inst_3)))) → @eq.{v+1} M m (@has_zero.zero.{v} M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@linear_map.ker.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ ∀ (m : V),
    @eq.{(max v u)+1}
      (@module.dual.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.inst.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            _inst_3
            (@module.dual.inst.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            _inst_3
            (@module.dual.inst.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)))
         (@module.dual.eval.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         m)
      (@has_zero.zero.{(max v u)}
         (@module.dual.{u (max v u)} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3))
         (@add_monoid.to_has_zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_group.to_add_monoid.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_comm_group.to_add_group.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@module.dual.add_comm_group_1.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)))))) →
    @eq.{v+1} V m
      (@has_zero.zero.{v} V
         (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213    intros v h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ ∀ (m : V),
    @eq.{(max v u)+1}
      (@module.dual.{u (max v u)} K
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@nonzero_comm_ring.to_comm_ring.{u} K
            (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
         (@module.dual.add_comm_group_1.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.inst.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3))
      (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
         (@linear_map.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            _inst_3
            (@module.dual.inst.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)))
         (@linear_map.has_coe_to_fun.{u v (max v u)} K V
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            _inst_2
            (@module.dual.add_comm_group_1.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            _inst_3
            (@module.dual.inst.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)))
         (@module.dual.eval.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         m)
      (@has_zero.zero.{(max v u)}
         (@module.dual.{u (max v u)} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3))
         (@add_monoid.to_has_zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_group.to_add_monoid.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_comm_group.to_add_group.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@module.dual.add_comm_group_1.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)))))) →
    @eq.{v+1} V m
      (@has_zero.zero.{v} V
         (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  @eq.{(max v u)+1}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.inst.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          _inst_3
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          _inst_3
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@module.dual.add_comm_group_1.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))))))
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214    rw linear_map.ext_iff at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_map.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type (max v u)} {γ : Type u} {rα : ring.{u} α} {gβ : add_comm_group.{(max v u)} β} {gγ : add_comm_group.{u} γ} {mβ : @module.{u (max v u)} α β rα gβ} {mγ : @module.{u u} α γ rα gγ} {f g : @linear_map.{u (max v u) u} α β γ rα gβ gγ mβ mγ}, iff (@eq.{(max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} α β γ rα gβ gγ mβ mγ) f g) (∀ (x : β), @eq.{u+1} γ (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{u (max v u) u} α β γ rα gβ gγ mβ mγ) f x) (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{u (max v u) u} α β γ rα gβ gγ mβ mγ) g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  @eq.{(max v u)+1}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.inst.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          _inst_3
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          _inst_3
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       v)
    (@has_zero.zero.{(max v u)}
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@add_monoid.to_has_zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_group.to_add_monoid.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_comm_group.to_add_group.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@module.dual.add_comm_group_1.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))))))
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x)
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    by_contradiction H,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1498, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the target of the main goal is a proposition `p`, `by_contradiction h` reduces the goal to proving `false` using the additional hypothesis `h : ¬ p`. If `h` is omitted, a name is generated automatically.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x)
⊢ @eq.{v+1} V v
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    rcases exists_subset_is_basis (linear_independent_singleton H) with ⟨b, hv, hb⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_subset_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_independent_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 1034, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 991, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_4 : @vector_space.{u v} K V _inst_1 _inst_2] {s : set.{v} V}, @linear_independent.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s) K V (λ (x : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s), @coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s) V (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s) V (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s) V (@coe_subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x s)))) x) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 → @Exists.{(max (v+1) 1)} (set.{v} V) (λ (b : set.{v} V), and (@has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V) s b) (@is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_4 : @vector_space.{u v} K V _inst_1 _inst_2] {x : V}, @ne.{v+1} V x (@has_zero.zero.{v} V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))) → @linear_independent.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x)) K V (λ (x_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x)), @coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x)) V (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x)) V (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x)) V (@coe_subtype.{v+1} V (λ (x_1 : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x_1 (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) x))))) x_1) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{v+1} V v (@has_zero.zero.{v} V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v ?l_1 v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) ?m_2 V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{?l_1} ?m_2
       (@division_ring.to_domain.{?l_1} ?m_2
          (@field.to_division_ring.{?l_1} ?m_2 (@discrete_field.to_field.{?l_1} ?m_2 ?m_3))))
    _inst_2
    ?m_4
⊢ false

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ Type ?l_1

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ discrete_field.{?l_1} ?m_2

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ @vector_space.{?l_1 v} ?m_2 V ?m_3 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217    swap 4, assumption,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opt_param.{1} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Move goal `n` to the front.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;nat?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v ?l_1 v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) ?m_2 V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{?l_1} ?m_2
       (@division_ring.to_domain.{?l_1} ?m_2
          (@field.to_division_ring.{?l_1} ?m_2 (@discrete_field.to_field.{?l_1} ?m_2 ?m_3))))
    _inst_2
    ?m_4
⊢ false

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ Type ?l_1

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ discrete_field.{?l_1} ?m_2

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ @vector_space.{?l_1 v} ?m_2 V ?m_3 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ @vector_space.{?l_1 v} ?m_2 V ?m_3 _inst_2

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v ?l_1 v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) ?m_2 V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{?l_1} ?m_2
       (@division_ring.to_domain.{?l_1} ?m_2
          (@field.to_division_ring.{?l_1} ?m_2 (@discrete_field.to_field.{?l_1} ?m_2 ?m_3))))
    _inst_2
    ?m_4
⊢ false

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ Type ?l_1

K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ discrete_field.{?l_1} ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    have hv&#x27; : v = (λ (i : b), i.val) ⟨v, hv (set.mem_singleton v)⟩ := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 516, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V) (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} (a : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) a (@singleton.{v v} α (set.{v} α) (@set.has_emptyc.{v} α) (@set.has_insert.{v} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    let hx := h (hb.to_dual v),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3), @eq.{u+1} K (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_add_comm_group.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_module.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))) (@linear_map.has_coe_to_fun.{u (max v u) u} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_add_comm_group.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_module.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))) (@module.dual.eval.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) v) x) (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_add_comm_group.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_module.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))) (@linear_map.has_coe_to_fun.{u (max v u) u} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_add_comm_group.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@ring.to_module.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))) (@has_zero.zero.{(max v u)} (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@add_monoid.to_has_zero.{(max v u)} (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@add_group.to_add_monoid.{(max v u)} (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@add_comm_group.to_add_group.{(max v u)} (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)))))) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The linear map from a vector space equipped with basis to its dual vector space,
taking basis elements to corresponding dual basis elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx : @eq.{u+1} K
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@module.dual.eval.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        v)
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v))
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@has_zero.zero.{(max v u)}
        (@module.dual.{u (max v u)} K
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@module.dual.inst.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3))
        (@add_monoid.to_has_zero.{(max v u)}
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@add_group.to_add_monoid.{(max v u)}
              (@module.dual.{u (max v u)} K
                 (@module.dual.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 (@module.dual.add_comm_group_1.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@module.dual.inst.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3))
              (@add_comm_group.to_add_group.{(max v u)}
                 (@module.dual.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))
                 (@module.dual.add_comm_group_1.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v)) :=
  h
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v v} K V
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
          _inst_1
          _inst_2
          _inst_3
          (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
               (λ (a b : V), _inst_4 a b)
               a
               b_1)
          (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
          hb)
       v)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220    erw [eval_apply, hv&#x27;, to_dual_apply, if_pos rfl, zero_apply _] at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='module.dual.eval_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.to_dual_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.zero_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] (v : M) (a : @module.dual.{u v} R M _inst_1 _inst_2 _inst_3), @eq.{u+1} R (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@module.dual.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) (@module.dual.has_coe_to_fun.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} R M (@module.dual.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3))) (@linear_map.has_coe_to_fun.{u v (max v u)} R M (@module.dual.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} R (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u v} R M _inst_1 _inst_2 _inst_3))) (@module.dual.eval.{u v} R M _inst_1 _inst_2 _inst_3) v) a) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} R M _inst_1 _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} R M _inst_1 _inst_2 _inst_3) a v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} V v ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i) (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v (hv v (@set.mem_singleton.{v} V v))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V ι : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{v+1} ι] {B : ι → V} (h : @is_basis.{v u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v v} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (B i)) (B j)) (@ite.{u+1} (@eq.{v+1} ι i j) (de i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type (max v u)} {M₂ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{(max v u)} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_6 : @module.{u (max v u)} R M _inst_1 _inst_2] [_inst_7 : @module.{u u} R M₂ _inst_1 _inst_3] (x : M), @eq.{u+1} M₂ (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))} (@linear_map.{u (max v u) u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (@linear_map.has_coe_to_fun.{u (max v u) u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (@has_zero.zero.{(max v u)} (@linear_map.{u (max v u) u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (@linear_map.has_zero.{u (max v u) u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) x) (@has_zero.zero.{u} M₂ (@add_monoid.to_has_zero.{u} M₂ (@add_group.to_add_monoid.{u} M₂ (@add_comm_group.to_add_group.{u} M₂ _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx : @eq.{u+1} K
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@module.dual.eval.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        v)
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v))
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@has_zero.zero.{(max v u)}
        (@module.dual.{u (max v u)} K
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@module.dual.inst.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3))
        (@add_monoid.to_has_zero.{(max v u)}
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@add_group.to_add_monoid.{(max v u)}
              (@module.dual.{u (max v u)} K
                 (@module.dual.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 (@module.dual.add_comm_group_1.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@module.dual.inst.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3))
              (@add_comm_group.to_add_group.{(max v u)}
                 (@module.dual.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))
                 (@module.dual.add_comm_group_1.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v)) :=
  h
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v v} K V
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
          _inst_1
          _inst_2
          _inst_3
          (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
               (λ (a b : V), _inst_4 a b)
               a
               b_1)
          (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
          hb)
       v)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          v)
       v)
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))
                   (@module.dual.add_comm_group_1.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          v))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
                (@hv v (@set.mem_singleton.{v} V v)))))
       ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
           @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
          (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
             (@hv v (@set.mem_singleton.{v} V v)))))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))
                   (@module.dual.add_comm_group_1.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
                (@hv v (@set.mem_singleton.{v} V v))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@ite.{u+1}
       (@eq.{v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
          (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
             (@hv v (@set.mem_singleton.{v} V v)))
          (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
             (@hv v (@set.mem_singleton.{v} V v))))
       (@subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
          (λ (a b : V), _inst_4 a b)
          (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
             (@hv v (@set.mem_singleton.{v} V v)))
          (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
             (@hv v (@set.mem_singleton.{v} V v))))
       K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))
                   (@module.dual.add_comm_group_1.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
                (@hv v (@set.mem_singleton.{v} V v))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
       (@linear_map.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u (max v u) u} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          K
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@has_zero.zero.{(max v u)}
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@add_monoid.to_has_zero.{(max v u)}
             (@module.dual.{u (max v u)} K
                (@module.dual.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                (@module.dual.add_comm_group_1.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3)
                (@module.dual.inst.{u v} K V
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   _inst_2
                   _inst_3))
             (@add_group.to_add_monoid.{(max v u)}
                (@module.dual.{u (max v u)} K
                   (@module.dual.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@nonzero_comm_ring.to_comm_ring.{u} K
                      (@euclidean_domain.to_nonzero_comm_ring.{u} K
                         (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                   (@module.dual.add_comm_group_1.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3)
                   (@module.dual.inst.{u v} K V
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      _inst_2
                      _inst_3))
                (@add_comm_group.to_add_group.{(max v u)}
                   (@module.dual.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))
                   (@module.dual.add_comm_group_1.{u (max v u)} K
                      (@module.dual.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                      (@module.dual.add_comm_group_1.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3)
                      (@module.dual.inst.{u v} K V
                         (@nonzero_comm_ring.to_comm_ring.{u} K
                            (@euclidean_domain.to_nonzero_comm_ring.{u} K
                               (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                         _inst_2
                         _inst_3))))))
       (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
          (@linear_map.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u v (max v u)} K V
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_3
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u v v} K V
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_4 a b)
                  a
                  b_1)
             (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
                @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             hb)
          ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
             (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
                (@hv v (@set.mem_singleton.{v} V v))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_group.to_add_monoid.{u} K
             (@add_comm_group.to_add_group.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx : @eq.{u+1} K
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           _inst_3
           (@module.dual.inst.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)))
        (@module.dual.eval.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        v)
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v))
  (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
     (@linear_map.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@linear_map.has_coe_to_fun.{u (max v u) u} K
        (@module.dual.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        K
        (@comm_ring.to_ring.{u} K
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
        (@module.dual.add_comm_group_1.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_add_comm_group.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
        (@module.dual.inst.{u v} K V
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           _inst_2
           _inst_3)
        (@ring.to_module.{u} K
           (@comm_ring.to_ring.{u} K
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
     (@has_zero.zero.{(max v u)}
        (@module.dual.{u (max v u)} K
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@nonzero_comm_ring.to_comm_ring.{u} K
              (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@module.dual.inst.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3))
        (@add_monoid.to_has_zero.{(max v u)}
           (@module.dual.{u (max v u)} K
              (@module.dual.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              (@module.dual.add_comm_group_1.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3)
              (@module.dual.inst.{u v} K V
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 _inst_2
                 _inst_3))
           (@add_group.to_add_monoid.{(max v u)}
              (@module.dual.{u (max v u)} K
                 (@module.dual.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@nonzero_comm_ring.to_comm_ring.{u} K
                    (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                 (@module.dual.add_comm_group_1.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3)
                 (@module.dual.inst.{u v} K V
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    _inst_2
                    _inst_3))
              (@add_comm_group.to_add_group.{(max v u)}
                 (@module.dual.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))
                 (@module.dual.add_comm_group_1.{u (max v u)} K
                    (@module.dual.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@nonzero_comm_ring.to_comm_ring.{u} K
                       (@euclidean_domain.to_nonzero_comm_ring.{u} K
                          (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                    (@module.dual.add_comm_group_1.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3)
                    (@module.dual.inst.{u v} K V
                       (@nonzero_comm_ring.to_comm_ring.{u} K
                          (@euclidean_domain.to_nonzero_comm_ring.{u} K
                             (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                       _inst_2
                       _inst_3))))))
     (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
        (@linear_map.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@linear_map.has_coe_to_fun.{u v (max v u)} K V
           (@module.dual.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           (@module.dual.add_comm_group_1.{u v} K V
              (@nonzero_comm_ring.to_comm_ring.{u} K
                 (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
              _inst_2
              _inst_3)
           _inst_3
           (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
        (@is_basis.to_dual.{u v v} K V
           (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
           _inst_1
           _inst_2
           _inst_3
           (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                (λ (a b : V), _inst_4 a b)
                a
                b_1)
           (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
              @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
           hb)
        v)) :=
  h
    (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
       (@linear_map.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
       (@is_basis.to_dual.{u v v} K V
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
          _inst_1
          _inst_2
          _inst_3
          (λ (a b_1 : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
               (λ (a b : V), _inst_4 a b)
               a
               b_1)
          (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
             @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
          hb)
       v)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_group.to_add_monoid.{u} K
             (@add_comm_group.to_add_group.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    exact one_ne_zero hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='one_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : zero_ne_one_class.{u} α], @ne.{u+1} α (@has_one.one.{u} α (@zero_ne_one_class.to_has_one.{u} α s)) (@has_zero.zero.{u} α (@zero_ne_one_class.to_has_zero.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@add_monoid.to_has_zero.{u} K (@add_group.to_add_monoid.{u} K (@add_comm_group.to_add_group.{u} K (@ring.to_add_comm_group.{u} K (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst : decidable_eq.{u+1} K,
_inst_4 : decidable_eq.{v+1} V,
_inst_5 :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
v : V,
h :
  ∀
  (x :
    @module.dual.{u v} K V
      (@nonzero_comm_ring.to_comm_ring.{u} K
         (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
      _inst_2
      _inst_3),
    @eq.{u+1} K
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))}
            (@linear_map.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@linear_map.has_coe_to_fun.{u v (max v u)} K V
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@module.dual.add_comm_group_1.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               _inst_3
               (@module.dual.inst.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)))
            (@module.dual.eval.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            v)
         x)
      (@coe_fn.{(max ((max v u)+1) (u+1)) (max ((max v u)+1) (u+1))}
         (@linear_map.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@linear_map.has_coe_to_fun.{u (max v u) u} K
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            K
            (@comm_ring.to_ring.{u} K
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
            (@module.dual.add_comm_group_1.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_add_comm_group.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
            (@module.dual.inst.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@ring.to_module.{u} K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
         (@has_zero.zero.{(max v u)}
            (@module.dual.{u (max v u)} K
               (@module.dual.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               (@module.dual.add_comm_group_1.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3)
               (@module.dual.inst.{u v} K V
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  _inst_2
                  _inst_3))
            (@add_monoid.to_has_zero.{(max v u)}
               (@module.dual.{u (max v u)} K
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                  (@module.dual.add_comm_group_1.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.inst.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3))
               (@add_group.to_add_monoid.{(max v u)}
                  (@module.dual.{u (max v u)} K
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     (@module.dual.add_comm_group_1.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.inst.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3))
                  (@add_comm_group.to_add_group.{(max v u)}
                     (@module.dual.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))
                     (@module.dual.add_comm_group_1.{u (max v u)} K
                        (@module.dual.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        (@module.dual.add_comm_group_1.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3)
                        (@module.dual.inst.{u v} K V
                           (@nonzero_comm_ring.to_comm_ring.{u} K
                              (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                 (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                           _inst_2
                           _inst_3))))))
         x),
H :
  not
    (@eq.{v+1} V v
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))),
b : set.{v} V,
hv :
  @has_subset.subset.{v} (set.{v} V) (@set.has_subset.{v} V)
    (@singleton.{v v} V (set.{v} V) (@set.has_emptyc.{v} V) (@set.has_insert.{v} V) v)
    b,
hb :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hv&#x27; :
  @eq.{v+1} V v
    ((λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b),
        @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i)
       (@subtype.mk.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) v
          (@hv v (@set.mem_singleton.{v} V v)))),
hx :
  @eq.{u+1} K
    (@has_one.one.{u} K
       (@zero_ne_one_class.to_has_one.{u} K
          (@domain.to_zero_ne_one_class.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_group.to_add_monoid.{u} K
             (@add_comm_group.to_add_group.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  theorem dual_dim_eq (h : dim K V &lt; omega) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_lt.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225    cardinal.lift.{v u} (dim K V) = dim K (dual K V) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type ((max v u)+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v}
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227    letI := classical.dec_eq (dual K V),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type (max v u)), decidable_eq.{(max (v+1) (u+1))} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v}
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    letI := classical.dec_eq V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v), decidable_eq.{v+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    rcases exists_is_basis_fintype h with ⟨b, hb, ⟨hf⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 329, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], @has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v} → @Exists.{(max (v+1) 1)} (set.{v} V) (λ (s : set.{v} V), and (@is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x s)) K V (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x s)) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (nonempty.{v+1} (fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    resetI,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    exact hb.dual_dim_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 189, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst : decidable_eq.{(max (v+1) (u+1))}
  (@module.dual.{u v} K V
     (@nonzero_comm_ring.to_comm_ring.{u} K
        (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
     _inst_2
     _inst_3) :=
  classical.dec_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (@vector_space.dim.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       _inst_1
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  set_option class.instance_max_depth 70</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  lemma eval_range (h : dim K V &lt; omega) : (eval K V).range = ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='module.dual.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 885, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_lt.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @linear_map.{u_1 u_2 (max u_2 u_1)} R M (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u (max v u)} R M₂ _inst_1 _inst_3 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max v u)) [c : lattice.has_top.{(max v u)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and
`vector_space.eval_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The range of a linear map `f : M → M₂` is a submodule of `M₂`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v}
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238    haveI := classical.dec_eq (dual K V),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type (max v u)), decidable_eq.{(max (v+1) (u+1))} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v}
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    haveI := classical.dec_eq (dual K (dual K V)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type (max v u)), decidable_eq.{(max ((max v u)+1) (u+1))} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type (max v u)) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{(max v u)} M] [_inst_3 : @module.{u (max v u)} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240    letI := classical.dec_eq V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v), decidable_eq.{v+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241    rcases exists_is_basis_fintype h with ⟨b, hb, ⟨hf⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 329, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], @has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v} → @Exists.{(max (v+1) 1)} (set.{v} V) (λ (s : set.{v} V), and (@is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x s)) K V (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x s)) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (nonempty.{v+1} (fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242    resetI,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    rw [← hb.to_dual_to_dual, range_comp, hb.to_dual_range, map_top, to_dual_range _],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='linear_map.range_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='submodule.map_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis.to_dual_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 894, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 138, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) _inst_3 (@is_basis.dual.vector_space.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))) (@linear_map.comp.{u v (max v u) (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (@is_basis.dual.vector_space.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u (max v u) v} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) _inst_1 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) (λ (a b : V), _inst_5 a b) a b_1) a b_1) (@is_basis.dual_basis.{u v v} K V (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) _inst_1 _inst_2 _inst_3 (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) (λ (a b : V), _inst_5 a b) a b_1) a b_1) (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) hb) (@is_basis.dual_basis_is_basis.{u v v} K V (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) _inst_1 _inst_2 _inst_3 (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) (λ (a b : V), _inst_5 a b) a b_1) a b_1) (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) hb hf)) (@is_basis.to_dual.{u v v} K V (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) _inst_1 _inst_2 _inst_3 (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) (λ (a b : V), _inst_5 a b) a b_1) a b_1) (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) hb)) (@module.dual.eval.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} {M₂ M₃ : Type (max v u)} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_4 : add_comm_group.{(max v u)} M₃] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u (max v u)} R M₂ _inst_1 _inst_3] [_inst_7 : @module.{u (max v u)} R M₃ _inst_1 _inst_4] (f : @linear_map.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (g : @linear_map.{u (max v u) (max v u)} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7), @eq.{(max v u)+1} (@submodule.{u (max v u)} R M₃ _inst_1 _inst_4 _inst_7) (@linear_map.range.{u v (max v u)} R M M₃ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 (@linear_map.comp.{u v (max v u) (max v u)} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g f)) (@submodule.map.{u (max v u) (max v u)} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7 g (@linear_map.range.{u v (max v u)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v u)+1} (@submodule.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.range.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3) (@is_basis.to_dual.{u v v} K V (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) _inst_1 _inst_2 _inst_3 (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)), @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) (λ (a b : V), _inst_5 a b) a b_1) a b_1) (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) hb)) (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@submodule.lattice.has_top.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M M₂ : Type (max v u)} {T : ring.{u} R} [_inst_1 : add_comm_group.{(max v u)} M] [_inst_2 : add_comm_group.{(max v u)} M₂] [_inst_3 : @module.{u (max v u)} R M T _inst_1] [_inst_4 : @module.{u (max v u)} R M₂ T _inst_2] (f : @linear_map.{u (max v u) (max v u)} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4), @eq.{(max v u)+1} (@submodule.{u (max v u)} R M₂ T _inst_2 _inst_4) (@submodule.map.{u (max v u) (max v u)} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4 f (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} R M T _inst_1 _inst_3) (@submodule.lattice.has_top.{u (max v u)} R M T _inst_1 _inst_3))) (@linear_map.range.{u (max v u) (max v u)} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type (max v u)} {ι : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{(max v u)} V] [_inst_3 : @vector_space.{u (max v u)} K V _inst_1 _inst_2] [de : decidable_eq.{v+1} ι] {B : ι → V} (h : @is_basis.{v u (max v u)} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) [fin : fintype.{v} ι], @eq.{(max v u)+1} (@submodule.{u (max v u)} K (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)) (@linear_map.range.{u (max v u) (max v u)} K V (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3) (@is_basis.to_dual.{u (max v u) v} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h)) (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} K (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)) (@submodule.lattice.has_top.{u (max v u)} K (@module.dual.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@is_basis.dual.vector_space.{u (max v u)} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.eval.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u v (max v u)} K V
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       _inst_2
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       _inst_3
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@linear_map.comp.{u v (max v u) (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@is_basis.dual.vector_space.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@is_basis.to_dual.{u (max v u) v} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@is_basis.dual_basis.{u v v} K V
                (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
                _inst_1
                _inst_2
                _inst_3
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   (λ
                    (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                      @subtype.decidable_eq.{v} V
                        (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                        (λ (a b : V), _inst_5 a b)
                        a
                        b_1)
                     a
                     b_1)
                (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
                hb)
             (@is_basis.dual_basis_is_basis.{u v v} K V
                (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
                _inst_1
                _inst_2
                _inst_3
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   (λ
                    (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                      @subtype.decidable_eq.{v} V
                        (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                        (λ (a b : V), _inst_5 a b)
                        a
                        b_1)
                     a
                     b_1)
                (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
                hb
                hf))
          (@is_basis.to_dual.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb)))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@submodule.map.{u (max v u) (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.to_dual.{u (max v u) v} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_5 a b)
                  a
                  b_1)
               a
               b_1)
          (@is_basis.dual_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb)
          (@is_basis.dual_basis_is_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb
             hf))
       (@linear_map.range.{u v (max v u)} K V
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          _inst_2
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          _inst_3
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (@is_basis.to_dual.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb)))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@submodule.map.{u (max v u) (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.to_dual.{u (max v u) v} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_5 a b)
                  a
                  b_1)
               a
               b_1)
          (@is_basis.dual_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb)
          (@is_basis.dual_basis_is_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb
             hf))
       (@lattice.has_top.top.{(max v u)}
          (@submodule.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.has_top.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3))))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ @eq.{(max v u)+1}
    (@submodule.{u (max v u)} K
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)))
    (@linear_map.range.{u (max v u) (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@comm_ring.to_ring.{u} K
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.add_comm_group_1.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
       (@module.dual.inst.{u (max v u)} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.inst.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3))
       (@is_basis.to_dual.{u (max v u) v} K
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
          _inst_1
          (@module.dual.add_comm_group_1.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)
          (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                  (λ (a b : V), _inst_5 a b)
                  a
                  b_1)
               a
               b_1)
          (@is_basis.dual_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb)
          (@is_basis.dual_basis_is_basis.{u v v} K V
             (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             _inst_1
             _inst_2
             _inst_3
             (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                (λ (a b_1 : @subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)),
                   @subtype.decidable_eq.{v} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)
                     (λ (a b : V), _inst_5 a b)
                     a
                     b_1)
                  a
                  b_1)
             (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
             hb
             hf)))
    (@lattice.has_top.top.{(max v u)}
       (@submodule.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)))
       (@submodule.lattice.has_top.{u (max v u)} K
          (@module.dual.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@comm_ring.to_ring.{u} K
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
          (@module.dual.add_comm_group_1.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))
          (@module.dual.inst.{u (max v u)} K
             (@module.dual.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             (@module.dual.add_comm_group_1.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3)
             (@module.dual.inst.{u v} K V
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ fintype.{v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
h :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    cardinal.omega.{v},
_inst :
  decidable_eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3),
_inst_4 :
  decidable_eq.{(max ((max v u)+1) (u+1))}
    (@module.dual.{u (max v u)} K
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       (@module.dual.add_comm_group_1.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)),
_inst_5 : decidable_eq.{v+1} V := classical.dec_eq.{v+1} V,
b : set.{v} V,
hb :
  @is_basis.{v u v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b)) K V
    (@subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
hf : fintype.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b)
⊢ fintype.{v} (@subtype.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  /-- A vector space is linearly equivalent to the dual of its dual space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  def eval_equiv (h : dim K V &lt; omega) : V ≃ₗ[K] dual K (dual K V) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_lt.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type (max v u)) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type (max v u)) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{(max v u)} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u (max v u)} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  linear_equiv.of_bijective (eval K V) eval_ker (eval_range h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv.of_bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.dual.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector_space.eval_ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector_space.eval_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1348, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M : Type v} {M₂ : Type w} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{w} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u w} R M₂ _inst_1 _inst_3] (f : @linear_map.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6), @eq.{v+1} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@linear_map.ker.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_bot.bot.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u v} R M _inst_1 _inst_2 _inst_5)) → @eq.{w+1} (@submodule.{u w} R M₂ _inst_1 _inst_3 _inst_6) (@linear_map.range.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_top.top.{w} (@submodule.{u w} R M₂ _inst_1 _inst_3 _inst_6) (@submodule.lattice.has_top.{u w} R M₂ _inst_1 _inst_3 _inst_6)) → @linear_equiv.{u v w} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], @linear_map.{u_1 u_2 (max u_2 u_1)} R M (@module.dual.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 (@module.dual.add_comm_group_1.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u_1 (max u_2 u_1)} R (@module.dual.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) _inst_1 (@module.dual.add_comm_group_1.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@module.dual.inst.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], @eq.{v+1} (@submodule.{u v} K V (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 _inst_3) (@linear_map.ker.{u v (max v u)} K V (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.eval.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], @has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v} → @eq.{(max v u)+1} (@submodule.{u (max v u)} K (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))) (@linear_map.range.{u v (max v u)} K V (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) _inst_3 (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.eval.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@lattice.has_top.top.{(max v u)} (@submodule.{u (max v u)} K (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))) (@submodule.lattice.has_top.{u (max v u)} K (@module.dual.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@comm_ring.to_ring.{u} K (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))) (@module.dual.add_comm_group_1.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3)) (@module.dual.inst.{u (max v u)} K (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.inst.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A bijective linear map is a linear equivalence. Here, bijectivity is described by saying that
the kernel of `f` is `{0}` and the range is the universal set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Maps a module M to the dual of the dual of M. See `vector_space.eval_range` and
`vector_space.eval_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  end vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  section dual_pair</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  open vector_space module module.dual linear_map function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  universes u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  variables {K : Type u} {V : Type v} {ι : Type w} [decidable_eq ι]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='decidable_eq.{w+1} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='discrete_field.{u} K'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='add_comm_group.{v} V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@vector_space.{u v} K V _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  local notation `V&#x27;` := dual K V</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  /-- `e` and `ε` have characteristic properties of a basis and its dual -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  structure dual_pair (e : ι → V) (ε : ι → V&#x27;) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  (eval : ∀ i j : ι, ε i (e j) = if i = j then 1 else 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (ε i) (e j)) (@ite.{u+1} (@eq.{w+1} ι i j) (_inst_1 i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_2)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_2)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  (total : ∀ {v : V}, (∀ i, ε i v = 0) → v = 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='total'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1045, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {v : V}, (∀ (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (ε i) v) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_2))))))) → @eq.{v+1} V v (@has_zero.zero.{v} V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  [finite : ∀ v : V, fintype {i | ε i v ≠ 0}]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π (v : V), fintype.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} ι) (@set.has_coe_to_sort.{w} ι) (@set_of.{w} ι (λ (i : ι), @ne.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) (ε i) v) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_2)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, (α → Prop) → set.{w} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  end dual_pair</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  namespace dual_pair</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  open vector_space module module.dual linear_map function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  universes u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  variables {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq ι]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Sort u → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  variables {e : ι → V} {ε : ι → dual K V} (h : dual_pair e ε)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='module.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='dual_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 41}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 264, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π (R : Type u_1) (M : Type u_2) [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : decidable_eq.{w+1} ι] [_inst_2 : discrete_field.{u} K] [_inst_3 : add_comm_group.{v} V] [_inst_4 : @vector_space.{u v} K V _inst_2 _inst_3], (ι → V) → (ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_2))) _inst_3 _inst_4) → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The dual space of an R-module M is the R-module of linear maps `M → R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`e` and `ε` have characteristic properties of a basis and its dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  include h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  /-- The coefficients of `v` on the basis `e` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  def coeffs (v : V) : ι →₀ K :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  { to_fun := λ i, ε i v,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    support := by { haveI := h.finite v, exact {i : ι | ε i v ≠ 0}.to_finset },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 264, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w}, (α → Prop) → set.{w} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ finset.{w} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V,
_inst :
  fintype.{w}
    (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} ι) (@set.has_coe_to_sort.{w} ι)
       (@set_of.{w} ι
          (λ (i : ι),
             @ne.{u+1} K
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.has_coe_to_fun.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (ε i)
                  v)
               (@has_zero.zero.{u} K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
⊢ finset.{w} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    mem_support_to_fun := by {intro i, rw set.mem_to_finset, exact iff.rfl } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='set.mem_to_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='iff.rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {s : set.{w} α} [_inst_1 : fintype.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} α) (@set.has_coe_to_sort.{w} α) s)] {a : α}, iff (@has_mem.mem.{w w} α (finset.{w} α) (@finset.has_mem.{w} α) a (@set.to_finset.{w} α s _inst_1)) (@has_mem.mem.{w w} α (set.{w} α) (@set.has_mem.{w} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a : Prop}, iff a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ ∀ (a : ι),
    iff
      (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) a
         (@set.to_finset.{w} ι
            (@set_of.{w} ι
               (λ (i : ι),
                  @ne.{u+1} K
                    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                       (@module.dual.{u v} K V
                          (@nonzero_comm_ring.to_comm_ring.{u} K
                             (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                          _inst_2
                          _inst_3)
                       (@module.dual.has_coe_to_fun.{u v} K V
                          (@nonzero_comm_ring.to_comm_ring.{u} K
                             (@euclidean_domain.to_nonzero_comm_ring.{u} K
                                (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                          _inst_2
                          _inst_3)
                       (ε i)
                       v)
                    (@has_zero.zero.{u} K
                       (@no_zero_divisors.to_has_zero.{u} K
                          (@domain.to_no_zero_divisors.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@dual_pair.finite.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v)))
      (@ne.{u+1} K
         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
            (@module.dual.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (@module.dual.has_coe_to_fun.{u v} K V
               (@nonzero_comm_ring.to_comm_ring.{u} K
                  (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
               _inst_2
               _inst_3)
            (ε a)
            v)
         (@has_zero.zero.{u} K
            (@no_zero_divisors.to_has_zero.{u} K
               (@domain.to_no_zero_divisors.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V,
i : ι
⊢ iff
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@set.to_finset.{w} ι
          (@set_of.{w} ι
             (λ (i : ι),
                @ne.{u+1} K
                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                     (@module.dual.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (@module.dual.has_coe_to_fun.{u v} K V
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                        _inst_2
                        _inst_3)
                     (ε i)
                     v)
                  (@has_zero.zero.{u} K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@dual_pair.finite.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v)))
    (@ne.{u+1} K
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.has_coe_to_fun.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (ε i)
          v)
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V,
i : ι
⊢ iff
    (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i
       (@set_of.{w} ι
          (λ (i : ι),
             @ne.{u+1} K
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                  (@module.dual.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (@module.dual.has_coe_to_fun.{u v} K V
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
                     _inst_2
                     _inst_3)
                  (ε i)
                  v)
               (@has_zero.zero.{u} K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
    (@ne.{u+1} K
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
          (@module.dual.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (@module.dual.has_coe_to_fun.{u v} K V
             (@nonzero_comm_ring.to_comm_ring.{u} K
                (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
             _inst_2
             _inst_3)
          (ε i)
          v)
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  @[simp] lemma coeffs_apply (v : V) (i : ι) : h.coeffs v i = ε i v := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dual_pair.coeffs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;line&#x27;: 283, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq.{w+1} ι] [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {e : ι → V} {ε : ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3}, @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε → V → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='The coefficients of `v` on the basis `e`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  omit h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  private def help_tcs : has_scalar K V := mul_action.to_has_scalar _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='has_scalar'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mul_action.to_has_scalar'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : monoid.{u} α] [c : @mul_action.{u v} α β _inst_1], has_scalar.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Typeclass for types with a scalar multiplication operation, denoted `•` (`\bu`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  local attribute [instance] help_tcs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='_private.3365327055.help_tcs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], has_scalar.{u v} K V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  /-- linear combinations of elements of `e`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  This is a convenient abbreviation for `finsupp.total _ V K e l` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  def lc (e : ι → V) (l : ι →₀ K) : V := l.sum (λ (i : ι) (a : K), a • (e i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type u} {γ : Type v} [_inst_1 : has_zero.{u} β] [_inst_2 : add_comm_monoid.{v} γ], @finsupp.{w u} α β _inst_1 → (α → β → γ) → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`sum f g` is the sum of `g a (f a)` over the support of `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  include h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  lemma dual_lc (l : ι →₀ K) (i : ι) : ε i (dual_pair.lc e l) = l i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dual_pair.lc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], (ι → V) → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' linear combinations of elements of `e`.
This is a convenient abbreviation for `finsupp.total _ V K e l`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304    erw linear_map.map_sum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='linear_map.map_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{u} γ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u u} α γ rα gγ} (f : @linear_map.{u v u} α β γ rα gβ gγ mβ mγ) {ι : Type w} {t : finset.{w} ι} {g : ι → β}, @eq.{u+1} γ (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{u v u} α β γ rα gβ gγ mβ mγ) f (@finset.sum.{w v} ι β (@add_comm_group.to_add_comm_monoid.{v} β gβ) t g)) (@finset.sum.{w u} ι γ (@add_comm_group.to_add_comm_monoid.{u} γ gγ) t (λ (i : ι), @coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@linear_map.{u v u} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{u v u} α β γ rα gβ gγ mβ mγ) f (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@finset.sum.{w u} ι K
       (@add_comm_group.to_add_comm_monoid.{u} K
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)
       (λ (i_1 : ι),
          @coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
            (@linear_map.{u v u} K V K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@ring.to_add_comm_group.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
               _inst_3
               (@ring.to_module.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
            (@linear_map.has_coe_to_fun.{u v u} K V K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@ring.to_add_comm_group.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
               _inst_3
               (@ring.to_module.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
            (ε i)
            ((λ (i : ι) (a : K), @has_scalar.smul.{u v} K V (@help_tcs.{u v} K V _inst_1 _inst_2 _inst_3) a (e i)) i_1
               (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
                  (@finsupp.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@finsupp.has_coe_to_fun.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  l
                  i_1))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305    simp only [h.eval, map_smul, smul_eq_mul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='linear_map.map_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_eq_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (e j)) (@ite.{u+1} (@eq.{w+1} ι i j) ((λ (a b : ι), dι a b) i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {rα : ring.{?l_1} α} {gβ : add_comm_group.{?l_2} β} {gγ : add_comm_group.{?l_3} γ} {mβ : @module.{?l_1 ?l_2} α β rα gβ} {mγ : @module.{?l_1 ?l_3} α γ rα gγ} (f : @linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (c : α) (x : β), @eq.{?l_3+1} γ (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α rα) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α rα) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β gβ)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α rα) (@add_comm_group.to_add_comm_monoid.{?l_2} β gβ) (@module.to_semimodule.{?l_1 ?l_2} α β rα gβ mβ)))) c x)) (@has_scalar.smul.{?l_1 ?l_3} α γ (@mul_action.to_has_scalar.{?l_1 ?l_3} α γ (@ring.to_monoid.{?l_1} α rα) (@distrib_mul_action.to_mul_action.{?l_1 ?l_3} α γ (@ring.to_monoid.{?l_1} α rα) (@add_group.to_add_monoid.{?l_3} γ (@add_comm_group.to_add_group.{?l_3} γ gγ)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_3} α γ (@ring.to_semiring.{?l_1} α rα) (@add_comm_group.to_add_comm_monoid.{?l_3} γ gγ) (@module.to_semimodule.{?l_1 ?l_3} α γ rα gγ mγ)))) c (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semiring.{?l_1} α] {a a&#x27; : α}, @eq.{?l_1+1} α (@has_scalar.smul.{?l_1 ?l_1} α α (@mul_action.to_has_scalar.{?l_1 ?l_1} α α (@semiring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_1} α α (@semiring.to_monoid.{?l_1} α _inst_1) (@add_comm_monoid.to_add_monoid.{?l_1} α (@semiring.to_add_comm_monoid.{?l_1} α _inst_1)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_1} α α _inst_1 (@semiring.to_add_comm_monoid.{?l_1} α _inst_1) (@semiring.to_semimodule.{?l_1} α _inst_1)))) a a&#x27;) (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1)) a a&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@finset.sum.{w u} ι K
       (@add_comm_group.to_add_comm_monoid.{u} K
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)
       (λ (i_1 : ι),
          @coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
            (@linear_map.{u v u} K V K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@ring.to_add_comm_group.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
               _inst_3
               (@ring.to_module.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
            (@linear_map.has_coe_to_fun.{u v u} K V K
               (@comm_ring.to_ring.{u} K
                  (@nonzero_comm_ring.to_comm_ring.{u} K
                     (@euclidean_domain.to_nonzero_comm_ring.{u} K
                        (@discrete_field.to_euclidean_domain.{u} K _inst_1))))
               _inst_2
               (@ring.to_add_comm_group.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
               _inst_3
               (@ring.to_module.{u} K
                  (@comm_ring.to_ring.{u} K
                     (@nonzero_comm_ring.to_comm_ring.{u} K
                        (@euclidean_domain.to_nonzero_comm_ring.{u} K
                           (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
            (ε i)
            ((λ (i : ι) (a : K), @has_scalar.smul.{u v} K V (@help_tcs.{u v} K V _inst_1 _inst_2 _inst_3) a (e i)) i_1
               (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
                  (@finsupp.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  (@finsupp.has_coe_to_fun.{w u} ι K
                     (@no_zero_divisors.to_has_zero.{u} K
                        (@domain.to_no_zero_divisors.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                  l
                  i_1))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@finset.sum.{w u} ι K
       (@add_comm_group.to_add_comm_monoid.{u} K
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)
       (λ (i_1 : ι),
          @has_mul.mul.{u} K
            (@mul_zero_class.to_has_mul.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
               (@finsupp.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.has_coe_to_fun.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               l
               i_1)
            (@ite.{u+1} (@eq.{w+1} ι i i_1) ((λ (a b : ι), dι a b) i i_1) K
               (@has_one.one.{u} K
                  (@zero_ne_one_class.to_has_one.{u} K
                     (@domain.to_zero_ne_one_class.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@has_zero.zero.{u} K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306    rw finset.sum_eq_single i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.sum_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : add_comm_monoid.{u} β] {s : finset.{w} α} {f : α → β} (a : α), (∀ (b : α), @has_mem.mem.{w w} α (finset.{w} α) (@finset.has_mem.{w} α) b s → @ne.{w+1} α b a → @eq.{u+1} β (f b) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β (@add_comm_monoid.to_add_monoid.{u} β _inst_1)))) → (not (@has_mem.mem.{w w} α (finset.{w} α) (@finset.has_mem.{w} α) a s) → @eq.{u+1} β (f a) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β (@add_comm_monoid.to_add_monoid.{u} β _inst_1)))) → @eq.{u+1} β (@finset.sum.{w u} α β _inst_1 s f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@finset.sum.{w u} ι K
       (@add_comm_group.to_add_comm_monoid.{u} K
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)
       (λ (i_1 : ι),
          @has_mul.mul.{u} K
            (@mul_zero_class.to_has_mul.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
               (@finsupp.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.has_coe_to_fun.{w u} ι K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               l
               i_1)
            (@ite.{u+1} (@eq.{w+1} ι i i_1) ((λ (a b : ι), dι a b) i i_1) K
               (@has_one.one.{u} K
                  (@zero_ne_one_class.to_has_one.{u} K
                     (@domain.to_zero_ne_one_class.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@has_zero.zero.{u} K
                  (@no_zero_divisors.to_has_zero.{u} K
                     (@domain.to_no_zero_divisors.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ ∀ (b : ι),
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) b
      (@finsupp.support.{w u} ι K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
         l) →
    @ne.{w+1} ι b i →
    @eq.{u+1} K
      (@has_mul.mul.{u} K
         (@mul_zero_class.to_has_mul.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            l
            b)
         (@ite.{u+1} (@eq.{w+1} ι i b) ((λ (a b : ι), dι a b) i b) K
            (@has_one.one.{u} K
               (@zero_ne_one_class.to_has_one.{u} K
                  (@domain.to_zero_ne_one_class.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@has_zero.zero.{u} K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_comm_monoid.to_add_monoid.{u} K
               (@add_comm_group.to_add_comm_monoid.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@comm_ring.to_ring.{u} K
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    { simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ ∀ (b : ι),
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) b
      (@finsupp.support.{w u} ι K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
         l) →
    @ne.{w+1} ι b i →
    @eq.{u+1} K
      (@has_mul.mul.{u} K
         (@mul_zero_class.to_has_mul.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            l
            b)
         (@ite.{u+1} (@eq.{w+1} ι i b) ((λ (a b : ι), dι a b) i b) K
            (@has_one.one.{u} K
               (@zero_ne_one_class.to_has_one.{u} K
                  (@domain.to_zero_ne_one_class.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@has_zero.zero.{u} K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_comm_monoid.to_add_monoid.{u} K
               (@add_comm_group.to_add_comm_monoid.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@comm_ring.to_ring.{u} K
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ ∀ (b : ι),
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) b
      (@finsupp.support.{w u} ι K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
         l) →
    @ne.{w+1} ι b i →
    @eq.{u+1} K
      (@has_mul.mul.{u} K
         (@mul_zero_class.to_has_mul.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            l
            b)
         (@ite.{u+1} (@eq.{w+1} ι i b) ((λ (a b : ι), dι a b) i b) K
            (@has_one.one.{u} K
               (@zero_ne_one_class.to_has_one.{u} K
                  (@domain.to_zero_ne_one_class.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@has_zero.zero.{u} K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_comm_monoid.to_add_monoid.{u} K
               (@add_comm_group.to_add_comm_monoid.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@comm_ring.to_ring.{u} K
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    { intros q q_in q_ne,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ ∀ (b : ι),
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) b
      (@finsupp.support.{w u} ι K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
         l) →
    @ne.{w+1} ι b i →
    @eq.{u+1} K
      (@has_mul.mul.{u} K
         (@mul_zero_class.to_has_mul.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            l
            b)
         (@ite.{u+1} (@eq.{w+1} ι i b) ((λ (a b : ι), dι a b) i b) K
            (@has_one.one.{u} K
               (@zero_ne_one_class.to_has_one.{u} K
                  (@domain.to_zero_ne_one_class.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@has_zero.zero.{u} K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_comm_monoid.to_add_monoid.{u} K
               (@add_comm_group.to_add_comm_monoid.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@comm_ring.to_ring.{u} K
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ ∀ (b : ι),
    @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) b
      (@finsupp.support.{w u} ι K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
         l) →
    @ne.{w+1} ι b i →
    @eq.{u+1} K
      (@has_mul.mul.{u} K
         (@mul_zero_class.to_has_mul.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
         (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
            (@finsupp.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@finsupp.has_coe_to_fun.{w u} ι K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            l
            b)
         (@ite.{u+1} (@eq.{w+1} ι i b) ((λ (a b : ι), dι a b) i b) K
            (@has_one.one.{u} K
               (@zero_ne_one_class.to_has_one.{u} K
                  (@domain.to_zero_ne_one_class.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            (@has_zero.zero.{u} K
               (@no_zero_divisors.to_has_zero.{u} K
                  (@domain.to_no_zero_divisors.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_comm_monoid.to_add_monoid.{u} K
               (@add_comm_group.to_add_comm_monoid.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@comm_ring.to_ring.{u} K
                        (@nonzero_comm_ring.to_comm_ring.{u} K
                           (@euclidean_domain.to_nonzero_comm_ring.{u} K
                              (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i q : ι,
q_in :
  @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) q
    (@finsupp.support.{w u} ι K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       l),
q_ne : @ne.{w+1} ι q i
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          q)
       (@ite.{u+1} (@eq.{w+1} ι i q) ((λ (a b : ι), dι a b) i q) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309      simp [q_ne.symm] },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{w+1} ι i q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i q : ι,
q_in :
  @has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) q
    (@finsupp.support.{w u} ι K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       l),
q_ne : @ne.{w+1} ι q i
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          q)
       (@ite.{u+1} (@eq.{w+1} ι i q) ((λ (a b : ι), dι a b) i q) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310    { intro p_not_in,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l)) →
  @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι,
p_not_in :
  not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l))
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311      simp [finsupp.not_mem_support_iff.1 p_not_in] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finsupp.not_mem_support_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_not_in'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type u} [_inst_1 : has_zero.{u} β] {f : @finsupp.{w u} α β _inst_1} {a : α}, iff (not (@has_mem.mem.{w w} α (finset.{w} α) (@finset.has_mem.{w} α) a (@finsupp.support.{w u} α β _inst_1 f))) (@eq.{u+1} β (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α β _inst_1) (@finsupp.has_coe_to_fun.{w u} α β _inst_1) f a) (@has_zero.zero.{u} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i (@finsupp.support.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι,
p_not_in :
  not
    (@has_mem.mem.{w w} ι (finset.{w} ι) (@finset.has_mem.{w} ι) i
       (@finsupp.support.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          l))
⊢ @eq.{u+1} K
    (@has_mul.mul.{u} K
       (@mul_zero_class.to_has_mul.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
       (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
          (@finsupp.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@finsupp.has_coe_to_fun.{w u} ι K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          l
          i)
       (@ite.{u+1} (@eq.{w+1} ι i i) ((λ (a b : ι), dι a b) i i) K
          (@has_one.one.{u} K
             (@zero_ne_one_class.to_has_one.{u} K
                (@domain.to_zero_ne_one_class.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@has_zero.zero.{u} K
             (@no_zero_divisors.to_has_zero.{u} K
                (@domain.to_no_zero_divisors.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@has_zero.zero.{u} K
       (@add_monoid.to_has_zero.{u} K
          (@add_comm_monoid.to_add_monoid.{u} K
             (@add_comm_group.to_add_comm_monoid.{u} K
                (@ring.to_add_comm_group.{u} K
                   (@comm_ring.to_ring.{u} K
                      (@nonzero_comm_ring.to_comm_ring.{u} K
                         (@euclidean_domain.to_nonzero_comm_ring.{u} K
                            (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  @[simp]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  lemma coeffs_lc (l : ι →₀ K) : h.coeffs (dual_pair.lc e l) = l :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dual_pair.coeffs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dual_pair.lc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 283, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type (max w u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq.{w+1} ι] [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {e : ι → V} {ε : ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3}, @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε → V → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], (ι → V) → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max w u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The coefficients of `v` on the basis `e`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' linear combinations of elements of `e`.
This is a convenient abbreviation for `finsupp.total _ V K e l`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  by { ext i, rw [h.coeffs_apply, h.dual_lc] }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (v : V) (i : ι), @eq.{u+1} K (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@finsupp.has_coe_to_fun.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), (λ (a b : ι), dι a b) a b) _inst_1 _inst_2 _inst_3 e ε h v) i) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (l : @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@finsupp.has_coe_to_fun.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) l i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
⊢ @eq.{(max (w+1) (u+1))}
    (@finsupp.{w u} ι K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h
          (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@no_zero_divisors.to_has_zero.{u} K
       (@domain.to_no_zero_divisors.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h
          (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       l
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  /-- For any v : V n, \sum_{p ∈ Q n} (ε p v) • e p = v -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  lemma decomposition (v : V) : dual_pair.lc e (h.coeffs v) = v :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='dual_pair.lc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dual_pair.coeffs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 283, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], (ι → V) → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq.{w+1} ι] [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {e : ι → V} {ε : ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3}, @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε → V → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title=' linear combinations of elements of `e`.
This is a convenient abbreviation for `finsupp.total _ V K e l`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The coefficients of `v` on the basis `e`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @eq.{v+1} V
    (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
       (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
    v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321    refine eq_of_sub_eq_zero (h.total _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq_of_sub_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 339, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 264, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] {a b : α}, @eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a b) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α _inst_1))) → @eq.{v+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @eq.{v+1} V
    (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
       (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
    v'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ ∀ (i : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.has_coe_to_fun.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (ε i)
         (@has_sub.sub.{v} V (@add_group_has_sub.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))
            (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
               (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
            v))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322    intros i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ ∀ (i : ι),
    @eq.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.has_coe_to_fun.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (ε i)
         (@has_sub.sub.{v} V (@add_group_has_sub.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))
            (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
               (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
            v))
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@has_sub.sub.{v} V (@add_group_has_sub.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))
          (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
             (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
          v))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323    simp [-sub_eq_add_neg, linear_map.map_sub, h.dual_lc, sub_eq_zero_iff_eq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='linear_map.map_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sub_eq_zero_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {rα : ring.{?l_1} α} {gβ : add_comm_group.{?l_2} β} {gγ : add_comm_group.{?l_3} γ} {mβ : @module.{?l_1 ?l_2} α β rα gβ} {mγ : @module.{?l_1 ?l_3} α γ rα gγ} (f : @linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (x y : β), @eq.{?l_3+1} γ (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f (@has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β gβ)) x y)) (@has_sub.sub.{?l_3} γ (@add_group_has_sub.{?l_3} γ (@add_comm_group.to_add_group.{?l_3} γ gγ)) (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f x) (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (l : @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@finsupp.has_coe_to_fun.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) l i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] {a b : α}, iff (@eq.{?l_1+1} α (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α _inst_1) a b) (@has_zero.zero.{?l_1} α (@add_monoid.to_has_zero.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1)))) (@eq.{?l_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V,
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@has_sub.sub.{v} V (@add_group_has_sub.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))
          (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e
             (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v))
          v))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  lemma mem_of_mem_span {H : set ι} {x : V} (hmem : x ∈ submodule.span K (e &#x27;&#x27; H)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='submodule.span'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2], set.{v} M → @submodule.{u v} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w} {β : Type v}, (α → β) → set.{w} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{w} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='The span of a set `s ⊆ M` is the smallest submodule of M that contains `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327    ∀ i : ι, ε i x ≠ 0 → i ∈ H :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type w} [c : has_mem.{w w} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{w} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H))
⊢ ∀ (i : ι),
    @ne.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.has_coe_to_fun.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (ε i)
         x)
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329    intros i hi,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H))
⊢ ∀ (i : ι),
    @ne.{u+1} K
      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
         (@module.dual.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (@module.dual.has_coe_to_fun.{u v} K V
            (@nonzero_comm_ring.to_comm_ring.{u} K
               (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
            _inst_2
            _inst_3)
         (ε i)
         x)
      (@has_zero.zero.{u} K
         (@no_zero_divisors.to_has_zero.{u} K
            (@domain.to_no_zero_divisors.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) →
    @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    rcases (finsupp.mem_span_iff_total _).mp hmem with ⟨l, supp_l, sum_l⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finsupp.mem_span_iff_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 373, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type w} {M : Type v} (R : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M _inst_1 _inst_2] {v : α → M} {s : set.{w} α} {x : M}, iff (@has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_3) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_3) x (@submodule.span.{u v} R M _inst_1 _inst_2 _inst_3 (@set.image.{w v} α M v s))) (@Exists.{(max w u)+1} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (λ (l : @finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))), @Exists.{0} (@has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) l (@finsupp.supported.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1) s)) (λ (H : @has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) l (@finsupp.supported.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1) s)), @eq.{v+1} M (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))} (@linear_map.{u (max w u) v} R (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_3) (@linear_map.has_coe_to_fun.{u (max w u) v} R (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_3) (@finsupp.total.{w v u} α M R _inst_1 _inst_2 _inst_3 v) l) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} V (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.has_mem.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) x (@submodule.span.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 (@set.image.{w v} ι V e H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
supp_l :
  @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    l
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       H),
sum_l :
  @eq.{v+1} V
    (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
       (@linear_map.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@linear_map.has_coe_to_fun.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@finsupp.total.{w v u} ι V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          e)
       l)
    x
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331    change dual_pair.lc e l = x at sum_l,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='dual_pair.lc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], (ι → V) → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' linear combinations of elements of `e`.
This is a convenient abbreviation for `finsupp.total _ V K e l`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
supp_l :
  @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    l
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       H),
sum_l :
  @eq.{v+1} V
    (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
       (@linear_map.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@linear_map.has_coe_to_fun.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@finsupp.total.{w v u} ι V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          e)
       l)
    x
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
supp_l :
  @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    l
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       H),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332    rw finsupp.mem_supported&#x27; at supp_l,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finsupp.mem_supported&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {M : Type u} (R : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : @module.{u u} R M _inst_1 _inst_2] {s : set.{w} α} (p : @finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))), iff (@has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{w u} α M _inst_2) (@finsupp.module.{w u u} α M R _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{w u} α M _inst_2) (@finsupp.module.{w u u} α M R _inst_1 _inst_2 _inst_3)) p (@finsupp.supported.{w u u} α M R _inst_1 _inst_2 _inst_3 s)) (∀ (x : α), not (@has_mem.mem.{w w} α (set.{w} α) (@set.has_mem.{w} α) x s) → @eq.{u+1} M (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) (@finsupp.has_coe_to_fun.{w u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) p x) (@has_zero.zero.{u} M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
supp_l :
  @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    l
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       H),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333    apply classical.by_contradiction,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
⊢ @has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
⊢ not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334    intro i_not,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
⊢ not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335    apply hi,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336    rw ← sum_l,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sum_l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337    simpa [h.dual_lc] using supp_l i i_not</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='supp_l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i_not'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (l : @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@finsupp.has_coe_to_fun.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) l i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : ι), not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) → @eq.{u+1} K (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@add_monoid.to_has_zero.{u} K (@add_group.to_add_monoid.{u} K (@add_comm_group.to_add_group.{u} K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))) (@finsupp.has_coe_to_fun.{w u} ι K (@add_monoid.to_has_zero.{u} K (@add_group.to_add_monoid.{u} K (@add_comm_group.to_add_group.{u} K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))) l x) (@has_zero.zero.{u} K (@add_monoid.to_has_zero.{u} K (@add_group.to_add_monoid.{u} K (@add_comm_group.to_add_group.{u} K (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
H : set.{w} ι,
x : V,
hmem :
  @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    x
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e H)),
i : ι,
hi :
  @ne.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       x)
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))),
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
sum_l : @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l) x,
supp_l :
  ∀ (x : ι),
    not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) x H) →
    @eq.{u+1} K
      (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
         (@finsupp.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         (@finsupp.has_coe_to_fun.{w u} ι K
            (@add_monoid.to_has_zero.{u} K
               (@add_group.to_add_monoid.{u} K
                  (@add_comm_group.to_add_group.{u} K
                     (@ring.to_add_comm_group.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
         l
         x)
      (@has_zero.zero.{u} K
         (@add_monoid.to_has_zero.{u} K
            (@add_group.to_add_monoid.{u} K
               (@add_comm_group.to_add_group.{u} K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))),
i_not : not (@has_mem.mem.{w w} ι (set.{w} ι) (@set.has_mem.{w} ι) i H)
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@has_zero.zero.{u} K
       (@no_zero_divisors.to_has_zero.{u} K
          (@domain.to_no_zero_divisors.{u} K
             (@division_ring.to_domain.{u} K
                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  lemma is_basis : is_basis K e :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @is_basis.{w u v} ι K V e
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @is_basis.{w u v} ι K V e
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @linear_independent.{w u v} ι K V e
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_top.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343    { rw linear_independent_iff,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='linear_independent_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type w} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2], iff (@linear_independent.{w u v} ι R M v _inst_1 _inst_2 _inst_4) (∀ (l : @finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))), @eq.{v+1} M (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))} (@linear_map.{u (max w u) v} R (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_4) (@linear_map.has_coe_to_fun.{u (max w u) v} R (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_4) (@finsupp.total.{w v u} ι M R _inst_1 _inst_2 _inst_4 v) l) (@has_zero.zero.{v} M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) → @eq.{(max (w+1) (u+1))} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) l (@has_zero.zero.{(max w u)} (@finsupp.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@finsupp.has_zero.{w u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @linear_independent.{w u v} ι K V e
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3

K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_top.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @linear_independent.{w u v} ι K V e
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ ∀
  (l :
    @finsupp.{w u} ι K
      (@mul_zero_class.to_has_zero.{u} K
         (@semiring.to_mul_zero_class.{u} K
            (@ring.to_semiring.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))),
    @eq.{v+1} V
      (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
         (@linear_map.{u (max w u) v} K
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            V
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@finsupp.add_comm_group.{w u} ι K
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_2
            (@finsupp.module.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_3)
         (@linear_map.has_coe_to_fun.{u (max w u) v} K
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            V
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@finsupp.add_comm_group.{w u} ι K
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_2
            (@finsupp.module.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_3)
         (@finsupp.total.{w v u} ι V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            _inst_3
            e)
         l)
      (@has_zero.zero.{v} V
         (@add_monoid.to_has_zero.{v} V
            (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))) →
    @eq.{(max (w+1) (u+1))}
      (@finsupp.{w u} ι K
         (@mul_zero_class.to_has_zero.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      l
      (@has_zero.zero.{(max w u)}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_zero.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344      intros l H,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ ∀
  (l :
    @finsupp.{w u} ι K
      (@mul_zero_class.to_has_zero.{u} K
         (@semiring.to_mul_zero_class.{u} K
            (@ring.to_semiring.{u} K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))),
    @eq.{v+1} V
      (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
         (@linear_map.{u (max w u) v} K
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            V
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@finsupp.add_comm_group.{w u} ι K
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_2
            (@finsupp.module.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_3)
         (@linear_map.has_coe_to_fun.{u (max w u) v} K
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            V
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            (@finsupp.add_comm_group.{w u} ι K
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_2
            (@finsupp.module.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
            _inst_3)
         (@finsupp.total.{w v u} ι V K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
            _inst_2
            _inst_3
            e)
         l)
      (@has_zero.zero.{v} V
         (@add_monoid.to_has_zero.{v} V
            (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))) →
    @eq.{(max (w+1) (u+1))}
      (@finsupp.{w u} ι K
         (@mul_zero_class.to_has_zero.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
      l
      (@has_zero.zero.{(max w u)}
         (@finsupp.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
         (@finsupp.has_zero.{w u} ι K
            (@mul_zero_class.to_has_zero.{u} K
               (@semiring.to_mul_zero_class.{u} K
                  (@ring.to_semiring.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V
    (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
       (@linear_map.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@linear_map.has_coe_to_fun.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@finsupp.total.{w v u} ι V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          e)
       l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
⊢ @eq.{(max (w+1) (u+1))}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    l
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_zero.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345      change dual_pair.lc e l = 0 at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='dual_pair.lc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], (ι → V) → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{w u} ι K (@mul_zero_class.to_has_zero.{u} K (@semiring.to_mul_zero_class.{u} K (@ring.to_semiring.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' linear combinations of elements of `e`.
This is a convenient abbreviation for `finsupp.total _ V K e l`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V
    (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
       (@linear_map.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@linear_map.has_coe_to_fun.{u (max w u) v} K
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@finsupp.add_comm_group.{w u} ι K
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_2
          (@finsupp.module.{w u u} ι K K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (@ring.to_add_comm_group.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (@ring.to_module.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          _inst_3)
       (@finsupp.total.{w v u} ι V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          e)
       l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
⊢ @eq.{(max (w+1) (u+1))}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    l
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_zero.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
⊢ @eq.{(max (w+1) (u+1))}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    l
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_zero.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346      ext i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
⊢ @eq.{(max (w+1) (u+1))}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    l
    (@has_zero.zero.{(max w u)}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_zero.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       l
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@finsupp.has_zero.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347      apply_fun ε i at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/apply_fun.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/apply_fun.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/apply_fun.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Apply a function to some local assumptions which are either equalities or
   inequalities. For instance, if the context contains `h : a = b` and
   some function `f` then `apply_fun f at h` turns `h` into `h : f a = f b`.
   When the assumption is an inequality `h : a ≤ b`, a side goal `monotone f`
   is created, unless this condition is provided using
   `apply_fun f at h using P` where `P : monotone f`, or the `mono` tactic can
   prove it.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Apply a function to some local assumptions which are either equalities or
   inequalities. For instance, if the context contains `h : a = b` and
   some function `f` then `apply_fun f at h` turns `h` into `h : f a = f b`.
   When the assumption is an inequality `h : a ≤ b`, a side goal `monotone f`
   is created, unless this condition is provided using
   `apply_fun f at h using P` where `P : monotone f`, or the `mono` tactic can
   prove it.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Apply a function to some local assumptions which are either equalities or
   inequalities. For instance, if the context contains `h : a = b` and
   some function `f` then `apply_fun f at h` turns `h` into `h : f a = f b`.
   When the assumption is an inequality `h : a ≤ b`, a side goal `monotone f`
   is created, unless this condition is provided using
   `apply_fun f at h using P` where `P : monotone f`, or the `mono` tactic can
   prove it.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
H :
  @eq.{v+1} V (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)
    (@has_zero.zero.{v} V
       (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))),
i : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       l
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@finsupp.has_zero.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
i : ι,
H :
  @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       l
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@finsupp.has_zero.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348      simpa [h.dual_lc] using H },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (l : @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (i : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)) (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))} (@finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@finsupp.has_coe_to_fun.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) l i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l)) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (@has_zero.zero.{v} V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
l :
  @finsupp.{w u} ι K
    (@mul_zero_class.to_has_zero.{u} K
       (@semiring.to_mul_zero_class.{u} K
          (@ring.to_semiring.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))),
i : ι,
H :
  @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@dual_pair.lc.{u v w} K V ι _inst_1 _inst_2 _inst_3 e l))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@module.dual.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (@module.dual.has_coe_to_fun.{u v} K V
          (@nonzero_comm_ring.to_comm_ring.{u} K
             (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
          _inst_2
          _inst_3)
       (ε i)
       (@has_zero.zero.{v} V
          (@add_monoid.to_has_zero.{v} V
             (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))))
⊢ @eq.{u+1} K
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       l
       i)
    (@coe_fn.{(max (w+1) (u+1)) (max (w+1) (u+1))}
       (@finsupp.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@finsupp.has_coe_to_fun.{w u} ι K
          (@mul_zero_class.to_has_zero.{u} K
             (@semiring.to_mul_zero_class.{u} K
                (@ring.to_semiring.{u} K
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
       (@has_zero.zero.{(max w u)}
          (@finsupp.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
          (@finsupp.has_zero.{w u} ι K
             (@mul_zero_class.to_has_zero.{u} K
                (@semiring.to_mul_zero_class.{u} K
                   (@ring.to_semiring.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_top.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349    { rw submodule.eq_top_iff&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='submodule.eq_top_iff&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 430, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] {p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5}, iff (@eq.{v+1} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) p (@lattice.has_top.top.{v} (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_top.{u v} R M _inst_1 _inst_2 _inst_5))) (∀ (x : M), @has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_5) x p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_top.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ ∀ (x : V),
    @has_mem.mem.{v v} V
      (@submodule.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3)
      (@submodule.has_mem.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3)
      x
      (@submodule.span.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3
         (@set.range.{v w+1} V ι e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350      intro v,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ ∀ (x : V),
    @has_mem.mem.{v v} V
      (@submodule.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3)
      (@submodule.has_mem.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3)
      x
      (@submodule.span.{u v} K V
         (@domain.to_ring.{u} K
            (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
         _inst_2
         _inst_3
         (@set.range.{v w+1} V ι e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    v
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351      rw [← set.image_univ, finsupp.mem_span_iff_total],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.image_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.mem_span_iff_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1213, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 373, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type v} {ι : Type w} {f : ι → β}, @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{w v} ι β f (@set.univ.{w} ι)) (@set.range.{v w+1} β ι f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {M : Type v} (R : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M _inst_1 _inst_2] {v : α → M} {s : set.{w} α} {x : M}, iff (@has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_3) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_3) x (@submodule.span.{u v} R M _inst_1 _inst_2 _inst_3 (@set.image.{w v} α M v s))) (@Exists.{(max w u)+1} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (λ (l : @finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))), @Exists.{0} (@has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) l (@finsupp.supported.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1) s)) (λ (H : @has_mem.mem.{(max w u) (max w u)} (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) (@submodule.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) (@submodule.has_mem.{u (max w u)} R (@finsupp.{w u} α R (@add_monoid.to_has_zero.{u} R (@add_group.to_add_monoid.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))) _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))) l (@finsupp.supported.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1) s)), @eq.{v+1} M (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))} (@linear_map.{u (max w u) v} R (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_3) (@linear_map.has_coe_to_fun.{u (max w u) v} R (@finsupp.{w u} α R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) M _inst_1 (@finsupp.add_comm_group.{w u} α R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_2 (@finsupp.module.{w u u} α R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1)) _inst_3) (@finsupp.total.{w v u} α M R _inst_1 _inst_2 _inst_3 v) l) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    v
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.range.{v w+1} V ι e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @has_mem.mem.{v v} V
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    (@submodule.has_mem.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    v
    (@submodule.span.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@set.image.{w v} ι V e (@set.univ.{w} ι)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @Exists.{(max w u)+1}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (λ
     (l :
       @finsupp.{w u} ι K
         (@mul_zero_class.to_has_zero.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))),
       @Exists.{0}
         (@has_mem.mem.{(max w u) (max w u)}
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@submodule.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@submodule.has_mem.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            l
            (@finsupp.supported.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@set.univ.{w} ι)))
         (λ
          (H :
            @has_mem.mem.{(max w u) (max w u)}
              (@finsupp.{w u} ι K
                 (@mul_zero_class.to_has_zero.{u} K
                    (@semiring.to_mul_zero_class.{u} K
                       (@ring.to_semiring.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
              (@submodule.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              (@submodule.has_mem.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              l
              (@finsupp.supported.{w u u} ι K K
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@ring.to_add_comm_group.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@ring.to_module.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@set.univ.{w} ι))),
            @eq.{v+1} V
              (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
                 (@linear_map.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@linear_map.has_coe_to_fun.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@finsupp.total.{w v u} ι V K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    _inst_2
                    _inst_3
                    e)
                 l)
              v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352      exact ⟨h.coeffs v, by simp, h.decomposition v⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='dual_pair.coeffs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 283, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq.{w+1} ι] [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {e : ι → V} {ε : ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3}, @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε → V → @finsupp.{w u} ι K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The coefficients of `v` on the basis `e`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='For any v : V n, \sum_{p ∈ Q n} (ε p v) • e p = v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @Exists.{(max w u)+1}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (λ
     (l :
       @finsupp.{w u} ι K
         (@mul_zero_class.to_has_zero.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))),
       @Exists.{0}
         (@has_mem.mem.{(max w u) (max w u)}
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@submodule.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@submodule.has_mem.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            l
            (@finsupp.supported.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@set.univ.{w} ι)))
         (λ
          (H :
            @has_mem.mem.{(max w u) (max w u)}
              (@finsupp.{w u} ι K
                 (@mul_zero_class.to_has_zero.{u} K
                    (@semiring.to_mul_zero_class.{u} K
                       (@ring.to_semiring.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
              (@submodule.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              (@submodule.has_mem.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              l
              (@finsupp.supported.{w u u} ι K K
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@ring.to_add_comm_group.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@ring.to_module.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@set.univ.{w} ι))),
            @eq.{v+1} V
              (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
                 (@linear_map.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@linear_map.has_coe_to_fun.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@finsupp.total.{w v u} ι V K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    _inst_2
                    _inst_3
                    e)
                 l)
              v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @has_mem.mem.{(max w u) (max w u)}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (@submodule.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@submodule.has_mem.{u (max w u)} K
       (@finsupp.{w u} ι K
          (@add_monoid.to_has_zero.{u} K
             (@add_group.to_add_monoid.{u} K
                (@add_comm_group.to_add_group.{u} K
                   (@ring.to_add_comm_group.{u} K
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@finsupp.add_comm_group.{w u} ι K
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@finsupp.module.{w u u} ι K K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          (@ring.to_add_comm_group.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
          (@ring.to_module.{u} K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
    (@dual_pair.coeffs.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h v)
    (@finsupp.supported.{w u u} ι K K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (@ring.to_add_comm_group.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@ring.to_module.{u} K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (@set.univ.{w} ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
v : V
⊢ @Exists.{(max w u)+1}
    (@finsupp.{w u} ι K
       (@mul_zero_class.to_has_zero.{u} K
          (@semiring.to_mul_zero_class.{u} K
             (@ring.to_semiring.{u} K
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
    (λ
     (l :
       @finsupp.{w u} ι K
         (@mul_zero_class.to_has_zero.{u} K
            (@semiring.to_mul_zero_class.{u} K
               (@ring.to_semiring.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))),
       @Exists.{0}
         (@has_mem.mem.{(max w u) (max w u)}
            (@finsupp.{w u} ι K
               (@mul_zero_class.to_has_zero.{u} K
                  (@semiring.to_mul_zero_class.{u} K
                     (@ring.to_semiring.{u} K
                        (@domain.to_ring.{u} K
                           (@division_ring.to_domain.{u} K
                              (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
            (@submodule.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            (@submodule.has_mem.{u (max w u)} K
               (@finsupp.{w u} ι K
                  (@add_monoid.to_has_zero.{u} K
                     (@add_group.to_add_monoid.{u} K
                        (@add_comm_group.to_add_group.{u} K
                           (@ring.to_add_comm_group.{u} K
                              (@domain.to_ring.{u} K
                                 (@division_ring.to_domain.{u} K
                                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@finsupp.add_comm_group.{w u} ι K
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
               (@finsupp.module.{w u u} ι K K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                  (@ring.to_add_comm_group.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                  (@ring.to_module.{u} K
                     (@domain.to_ring.{u} K
                        (@division_ring.to_domain.{u} K
                           (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
            l
            (@finsupp.supported.{w u u} ι K K
               (@domain.to_ring.{u} K
                  (@division_ring.to_domain.{u} K
                     (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
               (@ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@ring.to_module.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
               (@set.univ.{w} ι)))
         (λ
          (H :
            @has_mem.mem.{(max w u) (max w u)}
              (@finsupp.{w u} ι K
                 (@mul_zero_class.to_has_zero.{u} K
                    (@semiring.to_mul_zero_class.{u} K
                       (@ring.to_semiring.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
              (@submodule.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              (@submodule.has_mem.{u (max w u)} K
                 (@finsupp.{w u} ι K
                    (@add_monoid.to_has_zero.{u} K
                       (@add_group.to_add_monoid.{u} K
                          (@add_comm_group.to_add_group.{u} K
                             (@ring.to_add_comm_group.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))))
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@finsupp.add_comm_group.{w u} ι K
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                 (@finsupp.module.{w u u} ι K K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@ring.to_add_comm_group.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                    (@ring.to_module.{u} K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))
              l
              (@finsupp.supported.{w u u} ι K K
                 (@domain.to_ring.{u} K
                    (@division_ring.to_domain.{u} K
                       (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                 (@ring.to_add_comm_group.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@ring.to_module.{u} K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                 (@set.univ.{w} ι))),
            @eq.{v+1} V
              (@coe_fn.{(max ((max w u)+1) (v+1)) (max ((max w u)+1) (v+1))}
                 (@linear_map.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@linear_map.has_coe_to_fun.{u (max w u) v} K
                    (@finsupp.{w u} ι K
                       (@mul_zero_class.to_has_zero.{u} K
                          (@semiring.to_mul_zero_class.{u} K
                             (@ring.to_semiring.{u} K
                                (@domain.to_ring.{u} K
                                   (@division_ring.to_domain.{u} K
                                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))))
                    V
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    (@finsupp.add_comm_group.{w u} ι K
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_2
                    (@finsupp.module.{w u u} ι K K
                       (@domain.to_ring.{u} K
                          (@division_ring.to_domain.{u} K
                             (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                       (@ring.to_add_comm_group.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
                       (@ring.to_module.{u} K
                          (@domain.to_ring.{u} K
                             (@division_ring.to_domain.{u} K
                                (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
                    _inst_3)
                 (@finsupp.total.{w v u} ι V K
                    (@domain.to_ring.{u} K
                       (@division_ring.to_domain.{u} K
                          (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                    _inst_2
                    _inst_3
                    e)
                 l)
              v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  lemma eq_dual : ε = is_basis.dual_basis h.is_basis :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_basis.dual_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dual_pair.is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max w v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V}, @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 → ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [dι : decidable_eq.{w+1} ι] [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {e : ι → V} {ε : ι → @module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3}, @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε → @is_basis.{w u v} ι K V e (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Maps a basis for `V` to a basis for the dual space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{(max (w+1) (v+1) (u+1))}
    (ι →
     @module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    ε
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
       (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357    funext i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε
⊢ @eq.{(max (w+1) (v+1) (u+1))}
    (ι →
     @module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    ε
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
       (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i : ι
⊢ @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (ε i)
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
       (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358    refine h.is_basis.ext (λ _, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i : ι
⊢ @eq.{(max (v+1) (u+1))}
    (@module.dual.{u v} K V
       (@nonzero_comm_ring.to_comm_ring.{u} K
          (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
       _inst_2
       _inst_3)
    (ε i)
    (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
       (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i _x : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (ε i)
       (e _x))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
          (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h)
          i)
       (e _x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359    erw [is_basis.to_dual_apply, h.eval]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_basis.to_dual_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} {ι : Type w} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [de : decidable_eq.{w+1} ι] {B : ι → V} (h : @is_basis.{w u v} ι K V B (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@coe_fn.{(max (v+1) ((max v u)+1)) (max (v+1) ((max v u)+1))} (@linear_map.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@linear_map.has_coe_to_fun.{u v (max v u)} K V (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 (@module.dual.add_comm_group_1.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) _inst_3 (@is_basis.dual.vector_space.{u v} K V _inst_1 _inst_2 _inst_3)) (@is_basis.to_dual.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), de a b) B h) (B i)) (B j)) (@ite.{u+1} (@eq.{w+1} ι i j) (de i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : ι), @eq.{u+1} K (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (@module.dual.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (@module.dual.has_coe_to_fun.{u v} K V (@nonzero_comm_ring.to_comm_ring.{u} K (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1))) _inst_2 _inst_3) (ε i) (e j)) (@ite.{u+1} (@eq.{w+1} ι i j) ((λ (a b : ι), dι a b) i j) K (@has_one.one.{u} K (@zero_ne_one_class.to_has_one.{u} K (@domain.to_zero_ne_one_class.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@has_zero.zero.{u} K (@no_zero_divisors.to_has_zero.{u} K (@domain.to_no_zero_divisors.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i _x : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (ε i)
       (e _x))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
          (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h)
          i)
       (e _x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i _x : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (ε i)
       (e _x))
    (@ite.{u+1} (@eq.{w+1} ι i _x) ((λ (a b : ι), dι a b) i _x) K
       (@has_one.one.{u} K
          (@zero_ne_one_class.to_has_one.{u} K
             (@domain.to_zero_ne_one_class.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
       (@has_zero.zero.{u} K
          (@no_zero_divisors.to_has_zero.{u} K
             (@domain.to_no_zero_divisors.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
ι : Type w,
dι : decidable_eq.{w+1} ι,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
e : ι → V,
ε :
  ι →
  @module.dual.{u v} K V
    (@nonzero_comm_ring.to_comm_ring.{u} K
       (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))
    _inst_2
    _inst_3,
h : @dual_pair.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε,
i _x : ι
⊢ @eq.{u+1} K
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (ε i)
       (e _x))
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
       (@linear_map.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@linear_map.has_coe_to_fun.{u v u} K V K
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          (@ring.to_add_comm_group.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K (@discrete_field.to_euclidean_domain.{u} K _inst_1)))))
          _inst_3
          (@ring.to_module.{u} K
             (@comm_ring.to_ring.{u} K
                (@nonzero_comm_ring.to_comm_ring.{u} K
                   (@euclidean_domain.to_nonzero_comm_ring.{u} K
                      (@discrete_field.to_euclidean_domain.{u} K _inst_1))))))
       (@is_basis.dual_basis.{u v w} K V ι _inst_1 _inst_2 _inst_3 (λ (a b : ι), dι a b) e
          (@dual_pair.is_basis.{u v w} K V ι (λ (a b : ι), dι a b) _inst_1 _inst_2 _inst_3 e ε h)
          i)
       (e _x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362  end dual_pair</code></pre>
</body>