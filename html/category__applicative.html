<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Simon Hudon. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Simon Hudon</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Instances for identity and composition functors</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import category.functor</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  universe variables u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  section lemmas</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  open function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables {F : Type u → Type v}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables [applicative F] [is_lawful_applicative F]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variables {α β γ σ : Type u}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  attribute [functor_norm] seq_assoc pure_seq_eq_map map_pure seq_map_assoc map_seq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='is_lawful_applicative.seq_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_lawful_applicative.pure_seq_eq_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_lawful_applicative.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='seq_map_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='map_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='∀ {f : Type u → Type v} [_inst_1 : applicative.{u v} f] [c : @is_lawful_applicative.{u v} f _inst_1] {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)), @eq.{v+1} (f γ) (@has_seq.seq.{u v} f (@applicative.to_has_seq.{u v} f _inst_1) β γ h (@has_seq.seq.{u v} f (@applicative.to_has_seq.{u v} f _inst_1) α β g x)) (@has_seq.seq.{u v} f (@applicative.to_has_seq.{u v} f _inst_1) α γ (@has_seq.seq.{u v} f (@applicative.to_has_seq.{u v} f _inst_1) (α → β) (α → γ) (@functor.map.{u v} f (@applicative.to_functor.{u v} f _inst_1) (β → γ) ((α → β) → α → γ) (@function.comp.{u+1 u+1 u+1} α β γ) h) g) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : Type u → Type v} [_inst_1 : applicative.{u v} f] [c : @is_lawful_applicative.{u v} f _inst_1] {α β : Type u} (g : α → β) (x : f α), @eq.{v+1} (f β) (@has_seq.seq.{u v} (λ {α : Type u}, f α) (@applicative.to_has_seq.{u v} (λ {α : Type u}, f α) _inst_1) α β (@has_pure.pure.{u v} (λ {α : Type u}, f α) (@applicative.to_has_pure.{u v} (λ {α : Type u}, f α) _inst_1) (α → β) g) x) (@functor.map.{u v} f (@applicative.to_functor.{u v} f _inst_1) α β g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (f : Type u → Type v) [_inst_1 : applicative.{u v} f] [c : @is_lawful_applicative.{u v} f _inst_1] {α β : Type u} (g : α → β) (x : α), @eq.{v+1} (f β) (@functor.map.{u v} (λ {α : Type u}, f α) (@applicative.to_functor.{u v} (λ {α : Type u}, f α) _inst_1) α β g (@has_pure.pure.{u v} f (@applicative.to_has_pure.{u v} f _inst_1) α x)) (@has_pure.pure.{u v} f (@applicative.to_has_pure.{u v} f _inst_1) β (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type u} {F : Type u → Type v} [_inst_1 : applicative.{u v} F] [_inst_2 : @is_lawful_applicative.{u v} F _inst_1] (x : F (α → β)) (f : γ → α) (y : F γ), @eq.{v+1} (F β) (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) α β x (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) γ α f y)) (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) γ β (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) (α → β) (γ → β) (λ (m : α → β), @function.comp.{u+1 u+1 u+1} γ α β m f) x) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type u} {F : Type u → Type v} [_inst_1 : applicative.{u v} F] [_inst_2 : @is_lawful_applicative.{u v} F _inst_1] (f : β → γ) (x : F (α → β)) (y : F α), @eq.{v+1} (F γ) (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) β γ f (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) α β x y)) (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) α γ (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) (α → β) (α → γ) (@function.comp.{u+1 u+1 u+1} α β γ f) x) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplifier attribute'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  lemma applicative.map_seq_map (f : α → β → γ) (g : σ → β) (x : F α) (y : F σ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    (f &lt;$&gt; x) &lt;*&gt; (g &lt;$&gt; y) = (flip (∘) g ∘ f) &lt;$&gt; x &lt;*&gt; y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_seq.{u v} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} {φ : Sort w}, (α → β → φ) → β → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_seq.{u v} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  by simp [flip] with functor_norm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (α → β → φ) → β → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='F : Type u → Type v,
_inst_1 : applicative.{u v} F,
_inst_2 : @is_lawful_applicative.{u v} F _inst_1,
α β γ σ : Type u,
f : α → β → γ,
g : σ → β,
x : F α,
y : F σ
⊢ @eq.{v+1} (F γ)
    (@has_seq.seq.{u v} (λ {α : Type u}, F α) (@applicative.to_has_seq.{u v} (λ {α : Type u}, F α) _inst_1) β γ
       (@functor.map.{u v} (λ {α : Type u}, F α) (@applicative.to_functor.{u v} (λ {α : Type u}, F α) _inst_1) α
          (β → γ)
          f
          x)
       (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) σ β g y))
    (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) σ γ
       (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) α (σ → γ)
          (@function.comp.{u+1 u+1 u+1} α (β → γ) (σ → γ)
             (@flip.{u+1 u+1 u+1} (β → γ) (σ → β) (σ → γ) (@function.comp.{u+1 u+1 u+1} σ β γ) g)
             f)
          x)
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type v,
_inst_1 : applicative.{u v} F,
_inst_2 : @is_lawful_applicative.{u v} F _inst_1,
α β γ σ : Type u,
f : α → β → γ,
g : σ → β,
x : F α,
y : F σ
⊢ @eq.{v+1} (F γ)
    (@has_seq.seq.{u v} (λ {α : Type u}, F α) (@applicative.to_has_seq.{u v} (λ {α : Type u}, F α) _inst_1) β γ
       (@functor.map.{u v} (λ {α : Type u}, F α) (@applicative.to_functor.{u v} (λ {α : Type u}, F α) _inst_1) α
          (β → γ)
          f
          x)
       (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) σ β g y))
    (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) σ γ
       (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) α (σ → γ)
          (@function.comp.{u+1 u+1 u+1} α (β → γ) (σ → γ)
             (@flip.{u+1 u+1 u+1} (β → γ) (σ → β) (σ → γ) (@function.comp.{u+1 u+1 u+1} σ β γ) g)
             f)
          x)
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  lemma applicative.pure_seq_eq_map&#x27; (f : α → β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    (&lt;*&gt;) (pure f : F (α → β)) = (&lt;$&gt;) f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_seq.{u v} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  by ext; simp with functor_norm</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='F : Type u → Type v,
_inst_1 : applicative.{u v} F,
_inst_2 : @is_lawful_applicative.{u v} F _inst_1,
α β : Type u,
f : α → β
⊢ @eq.{v+1} (F α → F β)
    (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) α β
       (@has_pure.pure.{u v} F (@applicative.to_has_pure.{u v} F _inst_1) (α → β) f))
    (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) α β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type v,
_inst_1 : applicative.{u v} F,
_inst_2 : @is_lawful_applicative.{u v} F _inst_1,
α β : Type u,
f : α → β
⊢ @eq.{v+1} (F α → F β)
    (@has_seq.seq.{u v} F (@applicative.to_has_seq.{u v} F _inst_1) α β
       (@has_pure.pure.{u v} F (@applicative.to_has_pure.{u v} F _inst_1) (α → β) f))
    (@functor.map.{u v} F (@applicative.to_functor.{u v} F _inst_1) α β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  theorem applicative.ext {F} : ∀ {A1 : applicative F} {A2 : applicative F}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='applicative.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1] [_inst_4 : @is_lawful_applicative.{u u_1} F A2], (∀ {α : Type u} (x : α), @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) → (∀ {α β : Type u} (f : F (α → β)) (x : F α), @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) → @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='(Type u → Type u_1) → Type (max (u+1) u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='(Type u → Type u_1) → Type (max (u+1) u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    [@is_lawful_applicative F A1] [@is_lawful_applicative F A2]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (f : Type u → Type u_1) [_inst_1 : applicative.{u u_1} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (f : Type u → Type u_1) [_inst_1 : applicative.{u u_1} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    (H1 : ∀ {α : Type u} (x : α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} (x : α), @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      @has_pure.pure _ A1.to_has_pure _ x = @has_pure.pure _ A2.to_has_pure _ x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='applicative.to_has_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='applicative.to_has_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_pure.{u u_1} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (f : Type u → Type u_1) [c : applicative.{u u_1} f], has_pure.{u u_1} f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_pure.{u u_1} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (f : Type u → Type u_1) [c : applicative.{u u_1} f], has_pure.{u u_1} f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    (H2 : ∀ {α β : Type u} (f : F (α → β)) (x : F α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α β : Type u} (f : F (α → β)) (x : F α), @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      @has_seq.seq _ A1.to_has_seq _ _ f x = @has_seq.seq _ A2.to_has_seq _ _ f x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='applicative.to_has_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='applicative.to_has_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_seq.{u u_1} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (f : Type u → Type u_1) [c : applicative.{u u_1} f], has_seq.{u u_1} f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_seq.{u u_1} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (f : Type u → Type u_1) [c : applicative.{u u_1} f], has_seq.{u u_1} f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    A1 = A2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max (u+1) u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='applicative.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  | {to_functor := F1, seq := s1, pure := p1, seq_left := sl1, seq_right := sr1}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    {to_functor := F2, seq := s2, pure := p2, seq_left := sl2, seq_right := sr2} L1 L2 H1 H2 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    have : @p1 = @p2, {funext α x, apply H1}, subst this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max (u+1) u u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+2) (u+1) (u_1+1))} (Π {α : Type u}, α → F α) p1 p2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u+1) (u_1+1))} (Π {α : Type u}, α → F α) p1 p2

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
this : @eq.{(max (u+2) (u+1) (u_1+1))} (Π {α : Type u}, α → F α) p1 p2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
α : Type u,
x : α
⊢ @eq.{u_1+1} (F α) (@p1 α x) (@p2 α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
p2 : Π {α : Type u}, α → F α,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
this : @eq.{(max (u+2) (u+1) (u_1+1))} (Π {α : Type u}, α → F α) p1 p2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p2) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    have : @s1 = @s2, {funext α β f x, apply H2}, subst this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, F (α → β) → F α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, F (α → β) → F α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+2) (u_1+1))} (Π {α β : Type u}, F (α → β) → F α → F β) s1 s2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (Π {α β : Type u}, F (α → β) → F α → F β) s1 s2

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
this : @eq.{(max (u+2) (u_1+1))} (Π {α β : Type u}, F (α → β) → F α → F β) s1 s2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
α β : Type u,
f : F (α → β),
x : F α
⊢ @eq.{u_1+1} (F β) (@s1 α β f x) (@s2 α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
s2 : Π {α β : Type u}, F (α → β) → F α → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
this : @eq.{(max (u+2) (u_1+1))} (Π {α β : Type u}, F (α → β) → F α → F β) s1 s2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s2)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    cases L1, cases L2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_lawful_applicative.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_lawful_applicative.{u u_1} F (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1)),
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L2 :
  @is_lawful_applicative.{u u_1} F
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2)),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    have : F1 = F2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='functor.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='functor.{u u_1} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
this : @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    { resetI, apply functor.ext, intros,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='functor.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type u → Type u_1} {F1 F2 : functor.{u u_1} F} [_inst_3 : @is_lawful_functor.{u u_1} F F1] [_inst_4 : @is_lawful_functor.{u u_1} F F2], (∀ (α β : Type u) (f : α → β) (x : F α), @eq.{u_1+1} (F β) (@functor.map.{u u_1} F F1 α β f x) (@functor.map.{u u_1} F F2 α β f x)) → @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
this : @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ ∀ (α β : Type u) (f : α → β) (x : F α),
    @eq.{u_1+1} (F β) (@functor.map.{u u_1} F F1 α β f x) (@functor.map.{u u_1} F F2 α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
f : α → β,
x : F α
⊢ @eq.{u_1+1} (F β) (@functor.map.{u u_1} F F1 α β f x) (@functor.map.{u u_1} F F2 α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      exact (L1_pure_seq_eq_map _ _).symm.trans (L2_pure_seq_eq_map _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='L1_pure_seq_eq_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='L2_pure_seq_eq_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} (g : α → β) (x : F α), @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} (λ {α : Type u}, F α) (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α) (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α β (@has_pure.pure.{u u_1} (λ {α : Type u}, F α) (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α) (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) (α → β) g) x) (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α β g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} (g : α → β) (x : F α), @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} (λ {α : Type u}, F α) (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α) (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α β (@has_pure.pure.{u u_1} (λ {α : Type u}, F α) (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α) (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) (α → β) g) x) (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α β g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
f : α → β,
x : F α
⊢ @eq.{u_1+1} (F β) (@functor.map.{u u_1} F F1 α β f x) (@functor.map.{u u_1} F F2 α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
this : @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    subst this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
F2 : functor.{u u_1} F,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
this : @eq.{(max (u+1) u_1)+1} (functor.{u u_1} F) F1 F2
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F2 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    congr; funext α β x y,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x)
⊢ @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F)
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl1)
       (@has_seq_right.mk.{u u_1} F sr1))
    (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
       (@has_seq_left.mk.{u u_1} F sl2)
       (@has_seq_right.mk.{u u_1} F sr2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F α) (@sl1 α β x y) (@sl2 α β x y)

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F β) (@sr1 α β x y) (@sr2 α β x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    { exact (L1_seq_left_eq _ _).trans (L2_seq_left_eq _ _).symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='L1_seq_left_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='L2_seq_left_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='auto_param.{0} (∀ {α β : Type u} (a : F α) (b : F β), @eq.{u_1+1} (F α) (@has_seq_left.seq_left.{u u_1} F (@applicative.to_has_seq_left.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α β a b) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) β α (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α (β → α) (@function.const.{u+1 u+1} α β) a) b)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='auto_param.{0} (∀ {α β : Type u} (a : F α) (b : F β), @eq.{u_1+1} (F α) (@has_seq_left.seq_left.{u u_1} F (@applicative.to_has_seq_left.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α β a b) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) β α (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α (β → α) (@function.const.{u+1 u+1} α β) a) b)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F α) (@sl1 α β x y) (@sl2 α β x y)

F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F β) (@sr1 α β x y) (@sr2 α β x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F α) (@sl1 α β x y) (@sl2 α β x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F β) (@sr1 α β x y) (@sr2 α β x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    { exact (L1_seq_right_eq _ _).trans (L2_seq_right_eq _ _).symm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='L1_seq_right_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='L2_seq_right_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='auto_param.{0} (∀ {α β : Type u} (a : F α) (b : F β), @eq.{u_1+1} (F β) (@has_seq_right.seq_right.{u u_1} F (@applicative.to_has_seq_right.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α β a b) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) β β (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl1) (@has_seq_right.mk.{u u_1} F sr1))) α (β → β) (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β)) a) b)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='auto_param.{0} (∀ {α β : Type u} (a : F α) (b : F β), @eq.{u_1+1} (F β) (@has_seq_right.seq_right.{u u_1} F (@applicative.to_has_seq_right.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α β a b) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) β β (@functor.map.{u u_1} F (@applicative.to_functor.{u u_1} F (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1) (@has_seq_left.mk.{u u_1} F sl2) (@has_seq_right.mk.{u u_1} F sr2))) α (β → β) (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β)) a) b)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type u_1,
applicative.ext :
  ∀ {A1 A2 : applicative.{u u_1} F} [_inst_3 : @is_lawful_applicative.{u u_1} F A1]
  [_inst_4 : @is_lawful_applicative.{u u_1} F A2],
    (∀ {α : Type u} (x : α),
       @eq.{u_1+1} (F α) (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A1) α x)
         (@has_pure.pure.{u u_1} F (@applicative.to_has_pure.{u u_1} F A2) α x)) →
    (∀ {α β : Type u} (f : F (α → β)) (x : F α),
       @eq.{u_1+1} (F β) (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A1) α β f x)
         (@has_seq.seq.{u u_1} F (@applicative.to_has_seq.{u u_1} F A2) α β f x)) →
    @eq.{(max (u+2) (u_1+1))} (applicative.{u u_1} F) A1 A2,
F1 : functor.{u u_1} F,
p1 : Π {α : Type u}, α → F α,
s1 : Π {α β : Type u}, F (α → β) → F α → F β,
sl1 : Π {α β : Type u}, F α → F β → F α,
sr1 : Π {α β : Type u}, F α → F β → F β,
sl2 : Π {α β : Type u}, F α → F β → F α,
sr2 : Π {α β : Type u}, F α → F β → F β,
L1__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl1)
          (@has_seq_right.mk.{u u_1} F sr1))),
L1_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L1_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         x),
L1_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         (g x)),
L1_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L1_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl1)
                  (@has_seq_right.mk.{u u_1} F sr1)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl1)
                     (@has_seq_right.mk.{u u_1} F sr1)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
H1 :
  ∀ {α : Type u} (x : α),
    @eq.{u_1+1} (F α)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         x)
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         x),
H2 :
  ∀ {α β : Type u} (f : F (α → β)) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl1)
               (@has_seq_right.mk.{u u_1} F sr1)))
         α
         β
         f
         x)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         f
         x),
L2__to_is_lawful_functor :
  @is_lawful_functor.{u u_1} F
    (@applicative.to_functor.{u u_1} F
       (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
          (@has_seq_left.mk.{u u_1} F sl2)
          (@has_seq_right.mk.{u u_1} F sr2))),
L2_seq_left_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F α)
         (@has_seq_left.seq_left.{u u_1} F
            (@applicative.to_has_seq_left.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            α
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → α)
               (@function.const.{u+1 u+1} α β)
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_seq_right_eq :
  auto_param.{0}
    (∀ {α β : Type u} (a : F α) (b : F β),
       @eq.{u_1+1} (F β)
         (@has_seq_right.seq_right.{u u_1} F
            (@applicative.to_has_seq_right.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            a
            b)
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            β
            β
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               α
               (β → β)
               (@function.const.{u+1 u+1} (β → β) α (@id.{u+1} β))
               a)
            b))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str
                                  (string.str
                                     (string.str
                                        (string.str
                                           (string.str
                                              (string.str
                                                 (string.str
                                                    (string.str string.empty
                                                       (char.of_nat
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit0.{0} nat nat.has_add
                                                                         (@bit1.{0} nat nat.has_one nat.has_add
                                                                            (@has_one.one.{0} nat nat.has_one)))))))))
                                                    (char.of_nat
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@bit0.{0} nat nat.has_add
                                                                      (@bit1.{0} nat nat.has_one nat.has_add
                                                                         (@has_one.one.{0} nat nat.has_one)))))))))
                                                 (char.of_nat
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit0.{0} nat nat.has_add
                                                                   (@bit1.{0} nat nat.has_one nat.has_add
                                                                      (@has_one.one.{0} nat nat.has_one)))))))))
                                              (char.of_nat
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@bit0.{0} nat nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@bit1.{0} nat nat.has_one nat.has_add
                                                                   (@has_one.one.{0} nat nat.has_one)))))))))
                                           (char.of_nat
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@bit1.{0} nat nat.has_one nat.has_add
                                                                (@has_one.one.{0} nat nat.has_one)))))))))
                                        (char.of_nat
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@bit0.{0} nat nat.has_add
                                                          (@bit1.{0} nat nat.has_one nat.has_add
                                                             (@has_one.one.{0} nat nat.has_one)))))))))
                                     (char.of_nat
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@bit1.{0} nat nat.has_one nat.has_add
                                                          (@has_one.one.{0} nat nat.has_one)))))))))
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@bit0.{0} nat nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit1.{0} nat nat.has_one nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit0.{0} nat nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
L2_pure_seq_eq_map :
  ∀ {α β : Type u} (g : α → β) (x : F α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_has_seq.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         (@has_pure.pure.{u u_1} (λ {α : Type u}, F α)
            (@applicative.to_has_pure.{u u_1} (λ {α : Type u}, F α)
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            g)
         x)
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         x),
L2_map_pure :
  ∀ {α β : Type u} (g : α → β) (x : α),
    @eq.{u_1+1} (F β)
      (@functor.map.{u u_1} (λ {α : Type u}, F α)
         (@applicative.to_functor.{u u_1} (λ {α : Type u}, F α)
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@has_pure.pure.{u u_1} F
         (@applicative.to_has_pure.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         (g x)),
L2_seq_pure :
  ∀ {α β : Type u} (g : F (α → β)) (x : α),
    @eq.{u_1+1} (F β)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         β
         g
         (@has_pure.pure.{u u_1} F
            (@applicative.to_has_pure.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            x))
      (@functor.map.{u u_1} F
         (@applicative.to_functor.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         (α → β)
         β
         (λ (g : α → β), g x)
         g),
L2_seq_assoc :
  ∀ {α β γ : Type u} (x : F α) (g : F (α → β)) (h : F (β → γ)),
    @eq.{u_1+1} (F γ)
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         β
         γ
         h
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            α
            β
            g
            x))
      (@has_seq.seq.{u u_1} F
         (@applicative.to_has_seq.{u u_1} F
            (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
               (@has_seq_left.mk.{u u_1} F sl2)
               (@has_seq_right.mk.{u u_1} F sr2)))
         α
         γ
         (@has_seq.seq.{u u_1} F
            (@applicative.to_has_seq.{u u_1} F
               (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                  (@has_seq_left.mk.{u u_1} F sl2)
                  (@has_seq_right.mk.{u u_1} F sr2)))
            (α → β)
            (α → γ)
            (@functor.map.{u u_1} F
               (@applicative.to_functor.{u u_1} F
                  (@applicative.mk.{u u_1} F F1 (@has_pure.mk.{u u_1} F p1) (@has_seq.mk.{u u_1} F s1)
                     (@has_seq_left.mk.{u u_1} F sl2)
                     (@has_seq_right.mk.{u u_1} F sr2)))
               (β → γ)
               ((α → β) → α → γ)
               (@function.comp.{u+1 u+1 u+1} α β γ)
               h)
            g)
         x),
α β : Type u,
x : F α,
y : F β
⊢ @eq.{u_1+1} (F β) (@sr1 α β x y) (@sr2 α β x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  end lemmas</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  instance : is_comm_applicative id :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_comm_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (m : Type u_1 → Type u_2) [_inst_1 : applicative.{u_1 u_2} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  by refine { .. }; intros; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='⊢ @is_comm_applicative.{?l_1 ?l_1} (@id.{?l_1+2} (Type ?l_1))
    (@monad.to_applicative.{?l_1 ?l_1} (@id.{?l_1+2} (Type ?l_1)) id.monad.{?l_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @is_comm_applicative.{?l_1 ?l_1} (@id.{?l_1+2} (Type ?l_1))
    (@monad.to_applicative.{?l_1 ?l_1} (@id.{?l_1+2} (Type ?l_1)) id.monad.{?l_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  namespace comp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  open function (hiding comp)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  open functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  variables {F : Type u → Type w} {G : Type v → Type u}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  variables [applicative F] [applicative G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type w) → Type (max (u+1) w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='(Type v → Type u) → Type (max (v+1) u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  protected def seq {α β : Type v} : comp F G (α → β) → comp F G α → comp F G β</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='functor.comp.{u v w} F G (α → β) → functor.comp.{u v w} F G α → functor.comp.{u v w} F G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  | (comp.mk f) (comp.mk x) := comp.mk $ (&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='F (G (α → β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F (G α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type v → Type u} [c : has_seq.{v u} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {f : Type u → Type w} [c : functor.{u w} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type w} [c : has_seq.{u w} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  instance : has_pure (comp F G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  ⟨λ _ x, comp.mk $ pure $ pure x⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  instance : has_seq (comp F G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  ⟨λ _ _ f x, comp.seq f x⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (_x → _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] {α β : Type v}, functor.comp.{u v w} F G (α → β) → functor.comp.{u v w} F G α → functor.comp.{u v w} F G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (_x → _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  @[simp] protected lemma run_pure {α : Type v} :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    ∀ x : α, (pure x : comp F G α).run = pure (pure x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='run_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.comp.run'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (x : α), @eq.{w+1} (F (G α)) (@functor.comp.run.{u v w} F G α (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)) (@has_pure.pure.{u w} F (@applicative.to_has_pure.{u w} F _inst_1) (G α) (@has_pure.pure.{v u} G (@applicative.to_has_pure.{v u} G _inst_2) α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_pure.{v w} f] {α : Type v}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, functor.comp.{u v w} F G α → F (G α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type w} [c : has_pure.{u w} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type v → Type u} [c : has_pure.{v u} f] {α : Type v}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  | _ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type w} {a : α}, @eq.{w+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  @[simp] protected lemma run_seq {α β : Type v} (f : comp F G (α → β)) (x : comp F G α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    (f &lt;*&gt; x).run = (&lt;*&gt;) &lt;$&gt; f.run &lt;*&gt; x.run := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.comp.run'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.run'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.run'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, functor.comp.{u v w} F G α → F (G α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type u} [c : has_seq.{v u} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {f : Type u → Type w} [c : functor.{u w} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, functor.comp.{u v w} F G α → F (G α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type w} [c : has_seq.{u w} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, functor.comp.{u v w} F G α → F (G α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type w} {a : α}, @eq.{w+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  instance : applicative (comp F G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  { map := @comp.map F G _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='functor.comp.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : functor.{u w} F] [_inst_2 : functor.{v u} G] {α β : Type v}, (α → β) → functor.comp.{u v w} F G α → functor.comp.{u v w} F G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    seq := @comp.seq F G _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='comp.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] {α β : Type v}, functor.comp.{u v w} F G (α → β) → functor.comp.{u v w} F G α → functor.comp.{u v w} F G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    ..comp.has_pure }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comp.has_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 70, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G], has_pure.{v w} (functor.comp.{u v w} F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  variables [is_lawful_applicative F] [is_lawful_applicative G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (f : Type u → Type w) [_inst_1 : applicative.{u w} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (f : Type v → Type u) [_inst_1 : applicative.{v u} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  variables {α β γ : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  lemma map_pure (f : α → β) (x : α) : (f &lt;$&gt; pure x : comp F G β) = pure (f x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : functor.{v w} f] {α β : Type v}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  comp.ext $ by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} {α : Type v} {x y : functor.comp.{u v w} F G α}, @eq.{w+1} (F (G α)) (@functor.comp.run.{u v w} F G α x) (@functor.comp.run.{u v w} F G α y) → @eq.{w+1} (functor.comp.{u v w} F G α) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : α → β,
x : α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          α
          β
          f
          (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)))
    (@functor.comp.run.{u v w} F G β
       (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) β (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : α → β,
x : α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          α
          β
          f
          (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)))
    (@functor.comp.run.{u v w} F G β
       (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) β (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  lemma seq_pure (f : comp F G (α → β)) (x : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    f &lt;*&gt; pure x = (λ g : α → β, g x) &lt;$&gt; f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type v → Type w} [c : functor.{v w} f] {α β : Type v}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  comp.ext $ by simp [(∘)] with functor_norm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} {α : Type v} {x y : functor.comp.{u v w} F G α}, @eq.{w+1} (F (G α)) (@functor.comp.run.{u v w} F G α x) (@functor.comp.run.{u v w} F G α y) → @eq.{w+1} (functor.comp.{u v w} F G α) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : functor.comp.{u v w} F G (α → β),
x : α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f
          (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          (α → β)
          β
          (λ (g : α → β), g x)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : functor.comp.{u v w} F G (α → β),
x : α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f
          (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          (α → β)
          β
          (λ (g : α → β), g x)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  lemma seq_assoc (x : comp F G α) (f : comp F G (α → β)) (g : comp F G (β → γ)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99     g &lt;*&gt; (f &lt;*&gt; x) = (@function.comp α β γ &lt;$&gt; g) &lt;*&gt; f &lt;*&gt; x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='functor.comp.{u v w} F G (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : functor.{v w} f] {α β : Type v}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  comp.ext $ by simp [(∘)] with functor_norm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} {α : Type v} {x y : functor.comp.{u v w} F G α}, @eq.{w+1} (F (G α)) (@functor.comp.run.{u v w} F G α x) (@functor.comp.run.{u v w} F G α y) → @eq.{w+1} (functor.comp.{u v w} F G α) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β γ : Type v,
x : functor.comp.{u v w} F G α,
f : functor.comp.{u v w} F G (α → β),
g : functor.comp.{u v w} F G (β → γ)
⊢ @eq.{w+1} (F (G γ))
    (@functor.comp.run.{u v w} F G γ
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) β γ g
          (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f x)))
    (@functor.comp.run.{u v w} F G γ
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α γ
          (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) (α → β)
             (α → γ)
             (@functor.map.{v w} (functor.comp.{u v w} F G)
                (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
                   (@applicative.to_functor.{v u} G _inst_2))
                (β → γ)
                ((α → β) → α → γ)
                (@function.comp.{v+1 v+1 v+1} α β γ)
                g)
             f)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β γ : Type v,
x : functor.comp.{u v w} F G α,
f : functor.comp.{u v w} F G (α → β),
g : functor.comp.{u v w} F G (β → γ)
⊢ @eq.{w+1} (F (G γ))
    (@functor.comp.run.{u v w} F G γ
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) β γ g
          (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f x)))
    (@functor.comp.run.{u v w} F G γ
       (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α γ
          (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) (α → β)
             (α → γ)
             (@functor.map.{v w} (functor.comp.{u v w} F G)
                (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
                   (@applicative.to_functor.{v u} G _inst_2))
                (β → γ)
                ((α → β) → α → γ)
                (@function.comp.{v+1 v+1 v+1} α β γ)
                g)
             f)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  lemma pure_seq_eq_map (f : α → β) (x : comp F G α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    pure f &lt;*&gt; x = f &lt;$&gt; x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : has_seq.{v w} f] {α β : Type v}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type v → Type w} [c : functor.{v w} f] {α β : Type v}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  comp.ext $ by simp [applicative.pure_seq_eq_map&#x27;] with functor_norm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='functor.comp.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='applicative.pure_seq_eq_map&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} {α : Type v} {x y : functor.comp.{u v w} F G α}, @eq.{w+1} (F (G α)) (@functor.comp.run.{u v w} F G α x) (@functor.comp.run.{u v w} F G α y) → @eq.{w+1} (functor.comp.{u v w} F G α) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {F : Type ?l_1 → Type ?l_2} [_inst_1 : applicative.{?l_1 ?l_2} F] [_inst_2 : @is_lawful_applicative.{?l_1 ?l_2} F _inst_1] {α β : Type ?l_1} (f : α → β), @eq.{?l_2+1} (F α → F β) (@has_seq.seq.{?l_1 ?l_2} F (@applicative.to_has_seq.{?l_1 ?l_2} F _inst_1) α β (@has_pure.pure.{?l_1 ?l_2} F (@applicative.to_has_pure.{?l_1 ?l_2} F _inst_1) (α → β) f)) (@functor.map.{?l_1 ?l_2} F (@applicative.to_functor.{?l_1 ?l_2} F _inst_1) α β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : α → β,
x : functor.comp.{u v w} F G α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@has_seq.seq.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α) (@comp.has_seq.{u v w} F G _inst_1 _inst_2)
          α
          β
          (@has_pure.pure.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α)
             (@comp.has_pure.{u v w} F G _inst_1 _inst_2)
             (α → β)
             f)
          x))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          α
          β
          f
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='F : Type u → Type w,
G : Type v → Type u,
_inst_1 : applicative.{u w} F,
_inst_2 : applicative.{v u} G,
_inst_3 : @is_lawful_applicative.{u w} F _inst_1,
_inst_4 : @is_lawful_applicative.{v u} G _inst_2,
α β : Type v,
f : α → β,
x : functor.comp.{u v w} F G α
⊢ @eq.{w+1} (F (G β))
    (@functor.comp.run.{u v w} F G β
       (@has_seq.seq.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α) (@comp.has_seq.{u v w} F G _inst_1 _inst_2)
          α
          β
          (@has_pure.pure.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α)
             (@comp.has_pure.{u v w} F G _inst_1 _inst_2)
             (α → β)
             f)
          x))
    (@functor.comp.run.{u v w} F G β
       (@functor.map.{v w} (functor.comp.{u v w} F G)
          (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1)
             (@applicative.to_functor.{v u} G _inst_2))
          α
          β
          f
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  instance : is_lawful_applicative (comp F G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  { pure_seq_eq_map := @comp.pure_seq_eq_map F G _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='comp.pure_seq_eq_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] [_inst_3 : @is_lawful_applicative.{u w} F _inst_1] [_inst_4 : @is_lawful_applicative.{v u} G _inst_2] {α β : Type v} (f : α → β) (x : functor.comp.{u v w} F G α), @eq.{w+1} (functor.comp.{u v w} F G β) (@has_seq.seq.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β (@has_pure.pure.{v w} (λ {α : Type v}, functor.comp.{u v w} F G α) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) (α → β) f) x) (@functor.map.{v w} (functor.comp.{u v w} F G) (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1) (@applicative.to_functor.{v u} G _inst_2)) α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    map_pure := @comp.map_pure F G _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='comp.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] [_inst_3 : @is_lawful_applicative.{u w} F _inst_1] [_inst_4 : @is_lawful_applicative.{v u} G _inst_2] {α β : Type v} (f : α → β) (x : α), @eq.{w+1} (functor.comp.{u v w} F G β) (@functor.map.{v w} (functor.comp.{u v w} F G) (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1) (@applicative.to_functor.{v u} G _inst_2)) α β f (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)) (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    seq_pure := @comp.seq_pure F G _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='comp.seq_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] [_inst_3 : @is_lawful_applicative.{u w} F _inst_1] [_inst_4 : @is_lawful_applicative.{v u} G _inst_2] {α β : Type v} (f : functor.comp.{u v w} F G (α → β)) (x : α), @eq.{w+1} (functor.comp.{u v w} F G β) (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f (@has_pure.pure.{v w} (functor.comp.{u v w} F G) (@comp.has_pure.{u v w} F G _inst_1 _inst_2) α x)) (@functor.map.{v w} (functor.comp.{u v w} F G) (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1) (@applicative.to_functor.{v u} G _inst_2)) (α → β) β (λ (g : α → β), g x) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    seq_assoc := @comp.seq_assoc F G _ _ _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='comp.seq_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] [_inst_3 : @is_lawful_applicative.{u w} F _inst_1] [_inst_4 : @is_lawful_applicative.{v u} G _inst_2] {α β γ : Type v} (x : functor.comp.{u v w} F G α) (f : functor.comp.{u v w} F G (α → β)) (g : functor.comp.{u v w} F G (β → γ)), @eq.{w+1} (functor.comp.{u v w} F G γ) (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) β γ g (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α β f x)) (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) α γ (@has_seq.seq.{v w} (functor.comp.{u v w} F G) (@comp.has_seq.{u v w} F G _inst_1 _inst_2) (α → β) (α → γ) (@functor.map.{v w} (functor.comp.{u v w} F G) (@functor.comp.functor.{u v w} F G (@applicative.to_functor.{u w} F _inst_1) (@applicative.to_functor.{v u} G _inst_2)) (β → γ) ((α → β) → α → γ) (@function.comp.{v+1 v+1 v+1} α β γ) g) f) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  theorem applicative_id_comp {F} [AF : applicative F] [LF : is_lawful_applicative F] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    @comp.applicative id F _ _ = AF :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comp.applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='AF'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G], applicative.{v w} (functor.comp.{u v w} F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type (max (u_1+1) u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='applicative.{u_1 u_2} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  @applicative.ext F _ _ (@comp.is_lawful_applicative id F _ _ _ _) _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='applicative.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='comp.is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {F : Type u_1 → Type u_2} {A1 A2 : applicative.{u_1 u_2} F} [_inst_3 : @is_lawful_applicative.{u_1 u_2} F A1] [_inst_4 : @is_lawful_applicative.{u_1 u_2} F A2], (∀ {α : Type u_1} (x : α), @eq.{u_2+1} (F α) (@has_pure.pure.{u_1 u_2} F (@applicative.to_has_pure.{u_1 u_2} F A1) α x) (@has_pure.pure.{u_1 u_2} F (@applicative.to_has_pure.{u_1 u_2} F A2) α x)) → (∀ {α β : Type u_1} (f : F (α → β)) (x : F α), @eq.{u_2+1} (F β) (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F A1) α β f x) (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F A2) α β f x)) → @eq.{(max (u_1+2) (u_2+1))} (applicative.{u_1 u_2} F) A1 A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {F : Type u_2 → Type u_2} {G : Type u_1 → Type u_2} [_inst_1 : applicative.{u_2 u_2} F] [_inst_2 : applicative.{u_1 u_2} G] [_inst_3 : @is_lawful_applicative.{u_2 u_2} F _inst_1] [_inst_4 : @is_lawful_applicative.{u_1 u_2} G _inst_2], @is_lawful_applicative.{u_1 u_2} (functor.comp.{u_2 u_1 u_2} F G) (@comp.applicative.{u_2 u_1 u_2} F G _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_2+1)}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    (λ α x, rfl) (λ α β f x, rfl)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  theorem applicative_comp_id {F} [AF : applicative F] [LF : is_lawful_applicative F] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    @comp.applicative F id _ _ = AF :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comp.applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='AF'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G], applicative.{v w} (functor.comp.{u v w} F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type (max (u_1+1) u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='applicative.{u_1 u_2} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  @applicative.ext F _ _ (@comp.is_lawful_applicative F id _ _ _ _) _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='applicative.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='comp.is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {F : Type u_1 → Type u_2} {A1 A2 : applicative.{u_1 u_2} F} [_inst_3 : @is_lawful_applicative.{u_1 u_2} F A1] [_inst_4 : @is_lawful_applicative.{u_1 u_2} F A2], (∀ {α : Type u_1} (x : α), @eq.{u_2+1} (F α) (@has_pure.pure.{u_1 u_2} F (@applicative.to_has_pure.{u_1 u_2} F A1) α x) (@has_pure.pure.{u_1 u_2} F (@applicative.to_has_pure.{u_1 u_2} F A2) α x)) → (∀ {α β : Type u_1} (f : F (α → β)) (x : F α), @eq.{u_2+1} (F β) (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F A1) α β f x) (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F A2) α β f x)) → @eq.{(max (u_1+2) (u_2+1))} (applicative.{u_1 u_2} F) A1 A2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {F : Type u_1 → Type u_2} {G : Type u_1 → Type u_1} [_inst_1 : applicative.{u_1 u_2} F] [_inst_2 : applicative.{u_1 u_1} G] [_inst_3 : @is_lawful_applicative.{u_1 u_2} F _inst_1] [_inst_4 : @is_lawful_applicative.{u_1 u_1} G _inst_2], @is_lawful_applicative.{u_1 u_2} (functor.comp.{u_1 u_1 u_2} F G) (@comp.applicative.{u_1 u_1 u_2} F G _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    (λ α x, rfl) (λ α β f x, show id &lt;$&gt; f &lt;*&gt; x = f &lt;*&gt; x, by rw id_map)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_lawful_functor.id_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : functor.{u_1 u_2} f] {α β : Type u_1}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : has_seq.{u_1 u_2} f] {α β : Type u_1}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : has_seq.{u_1 u_2} f] {α β : Type u_1}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : Type u_1 → Type u_2} [_inst_1 : functor.{u_1 u_2} f] [c : @is_lawful_functor.{u_1 u_2} f _inst_1] {α : Type u_1} (x : f α), @eq.{u_2+1} (f α) (@functor.map.{u_1 u_2} f _inst_1 α α (@id.{u_1+1} α) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='lime'><a title='F : Type u_1 → Type u_2,
AF : applicative.{u_1 u_2} F,
LF : @is_lawful_applicative.{u_1 u_2} F AF,
α β : Type u_1,
f : F (α → β),
x : F α
⊢ @eq.{u_2+1} (F β)
    (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F AF) α β
       (@functor.map.{u_1 u_2} F (@applicative.to_functor.{u_1 u_2} F AF) (α → β) (α → β)
          (@id.{u_1+1} (α → β))
          f)
       x)
    (@has_seq.seq.{u_1 u_2} F (@applicative.to_has_seq.{u_1 u_2} F AF) α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  open is_comm_applicative</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  instance {f : Type u → Type w} {g : Type v → Type u}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    [applicative f] [applicative g]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type w) → Type (max (u+1) w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type v → Type u) → Type (max (v+1) u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126    [is_comm_applicative f] [is_comm_applicative g] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_comm_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_comm_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (m : Type u → Type w) [_inst_1 : applicative.{u w} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (m : Type v → Type u) [_inst_1 : applicative.{v u} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    is_comm_applicative (comp f g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_comm_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (m : Type u_1 → Type u_2) [_inst_1 : applicative.{u_1 u_2} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type w) → (Type v → Type u) → Type v → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  by { refine { .. @comp.is_lawful_applicative f g _ _ _ _, .. },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='comp.is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {F : Type u → Type w} {G : Type v → Type u} [_inst_1 : applicative.{u w} F] [_inst_2 : applicative.{v u} G] [_inst_3 : @is_lawful_applicative.{u w} F _inst_1] [_inst_4 : @is_lawful_applicative.{v u} G _inst_2], @is_lawful_applicative.{v w} (functor.comp.{u v w} F G) (@comp.applicative.{u v w} F G _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6
⊢ @is_comm_applicative.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6
⊢ ∀ {α β : Type v} (a : functor.comp.{u v w} f g α) (b : functor.comp.{u v w} f g β),
    @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
      (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
         (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
         β
         (prod.{v v} α β)
         (@functor.map.{v w} (functor.comp.{u v w} f g)
            (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
            α
            (β → prod.{v v} α β)
            (@prod.mk.{v v} α β)
            a)
         b)
      (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
         (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
         α
         (prod.{v v} α β)
         (@functor.map.{v w} (functor.comp.{u v w} f g)
            (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
            β
            (α → prod.{v v} α β)
            (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
            b)
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129       intros, casesm* comp _ _ _, simp! [map,has_seq.seq] with functor_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 779, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 779, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(Type ?l_1 → Type ?l_2) → (Type ?l_3 → Type ?l_1) → Type ?l_3 → Type ?l_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorthand for `cases_matching`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`functor.comp` is a wrapper around `function.comp` for types.
   It prevents Lean&#x27;s type class resolution mechanism from trying
   a `functor (comp F id)` when `functor F` would do.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorthand for `cases_matching`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='casesm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='casesm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6
⊢ ∀ {α β : Type v} (a : functor.comp.{u v w} f g α) (b : functor.comp.{u v w} f g β),
    @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
      (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
         (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
         β
         (prod.{v v} α β)
         (@functor.map.{v w} (functor.comp.{u v w} f g)
            (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
            α
            (β → prod.{v v} α β)
            (@prod.mk.{v v} α β)
            a)
         b)
      (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
         (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
         α
         (prod.{v v} α β)
         (@functor.map.{v w} (functor.comp.{u v w} f g)
            (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
            β
            (α → prod.{v v} α β)
            (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
            b)
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
       (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
       β
       (prod.{v v} α β)
       (@functor.map.{v w} (functor.comp.{u v w} f g)
          (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
          α
          (β → prod.{v v} α β)
          (@prod.mk.{v v} α β)
          a)
       b)
    (@has_seq.seq.{v w} (functor.comp.{u v w} f g)
       (@applicative.to_has_seq.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
       α
       (prod.{v v} α β)
       (@functor.map.{v w} (functor.comp.{u v w} f g)
          (@applicative.to_functor.{v w} (functor.comp.{u v w} f g) (@comp.applicative.{u v w} f g _inst_5 _inst_6))
          β
          (α → prod.{v v} α β)
          (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
          b)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g β) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (β → prod.{v v} α β))
             (g β → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (β → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g α) (g (β → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                      (@prod.mk.{v v} α β))
                   a)))
          b))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (α → prod.{v v} α β))
             (g α → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (α → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g β) (g (α → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                      (λ (b : β) (a : α), @prod.mk.{v v} α β a b))
                   b)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130       rw [commutative_map],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_comm_applicative.commutative_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 199, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m : Type u → Type w} [_inst_1 : applicative.{u w} m] [_inst_2 : @is_comm_applicative.{u w} m _inst_1] {α β γ : Type u} (a : m α) (b : m β) {f : α → β → γ}, @eq.{w+1} (m γ) (@has_seq.seq.{u w} (λ {α : Type u}, m α) (@applicative.to_has_seq.{u w} (λ {α : Type u}, m α) _inst_1) β γ (@functor.map.{u w} (λ {α : Type u}, m α) (@applicative.to_functor.{u w} (λ {α : Type u}, m α) _inst_1) α (β → γ) f a) b) (@has_seq.seq.{u w} m (@applicative.to_has_seq.{u w} m _inst_1) α γ (@functor.map.{u w} m (@applicative.to_functor.{u w} m _inst_1) β (α → γ) (@flip.{u+1 u+1 u+1} α β γ f) b) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g β) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (β → prod.{v v} α β))
             (g β → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (β → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g α) (g (β → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                      (@prod.mk.{v v} α β))
                   a)))
          b))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (α → prod.{v v} α β))
             (g α → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (α → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g β) (g (α → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                      (λ (b : β) (a : α), @prod.mk.{v v} α β a b))
                   b)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} (λ (α : Type u), f α) (@applicative.to_has_seq.{u w} (λ (α : Type u), f α) _inst_5)
          (g (β → prod.{v v} α β))
          (g (prod.{v v} α β))
          (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} (λ (α : Type u), f α) _inst_5)
             (g β)
             (g (β → prod.{v v} α β) → g (prod.{v v} α β))
             (@flip.{u+1 u+1 u+1} (g (β → prod.{v v} α β)) (g β) (g (prod.{v v} α β))
                (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)))
             b)
          (@functor.comp.mk.{u v w} f g (β → prod.{v v} α β)
             (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g α) (g (β → prod.{v v} α β))
                (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                   (@prod.mk.{v v} α β))
                a))))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (α → prod.{v v} α β))
             (g α → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (α → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g β) (g (α → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                      (λ (b : β) (a : α), @prod.mk.{v v} α β a b))
                   b)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131       simp [comp.mk,flip,(∘)] with functor_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {F : Type ?l_1 → Type ?l_2} {G : Type ?l_3 → Type ?l_1} {α : Type ?l_3}, F (G α) → functor.comp.{?l_1 ?l_3 ?l_2} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (α → β → φ) → β → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} (λ (α : Type u), f α) (@applicative.to_has_seq.{u w} (λ (α : Type u), f α) _inst_5)
          (g (β → prod.{v v} α β))
          (g (prod.{v v} α β))
          (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} (λ (α : Type u), f α) _inst_5)
             (g β)
             (g (β → prod.{v v} α β) → g (prod.{v v} α β))
             (@flip.{u+1 u+1 u+1} (g (β → prod.{v v} α β)) (g β) (g (prod.{v v} α β))
                (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)))
             b)
          (@functor.comp.mk.{u v w} f g (β → prod.{v v} α β)
             (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g α) (g (β → prod.{v v} α β))
                (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                   (@prod.mk.{v v} α β))
                a))))
    (@functor.comp.mk.{u v w} f g (prod.{v v} α β)
       (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
          (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g (α → prod.{v v} α β))
             (g α → g (prod.{v v} α β))
             (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β))
             (@functor.comp.mk.{u v w} f g (α → prod.{v v} α β)
                (@functor.map.{u w} f (@applicative.to_functor.{u w} f _inst_5) (g β) (g (α → prod.{v v} α β))
                   (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                      (λ (b : β) (a : α), @prod.mk.{v v} α β a b))
                   b)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@has_seq.seq.{u w} (λ (α : Type u), f α) (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
       (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} f _inst_5) (g β)
          (g α → g (prod.{v v} α β))
          (λ (x : g β) (x_1 : g α),
             @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)
               (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                  (@prod.mk.{v v} α β)
                  x_1)
               x)
          b)
       a)
    (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
       (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} f _inst_5) (g β)
          (g α → g (prod.{v v} α β))
          (λ (x : g β),
             @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β)
               (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                  (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
                  x))
          b)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132       congr, funext, rw [commutative_map], congr }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='is_comm_applicative.commutative_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 199, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m : Type v → Type u} [_inst_1 : applicative.{v u} m] [_inst_2 : @is_comm_applicative.{v u} m _inst_1] {α β γ : Type v} (a : m α) (b : m β) {f : α → β → γ}, @eq.{u+1} (m γ) (@has_seq.seq.{v u} (λ {α : Type v}, m α) (@applicative.to_has_seq.{v u} (λ {α : Type v}, m α) _inst_1) β γ (@functor.map.{v u} (λ {α : Type v}, m α) (@applicative.to_functor.{v u} (λ {α : Type v}, m α) _inst_1) α (β → γ) f a) b) (@has_seq.seq.{v u} m (@applicative.to_has_seq.{v u} m _inst_1) α γ (@functor.map.{v u} m (@applicative.to_functor.{v u} m _inst_1) β (α → γ) (@flip.{v+1 v+1 v+1} α β γ f) b) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{w+1} (functor.comp.{u v w} f g (prod.{v v} α β))
    (@has_seq.seq.{u w} (λ (α : Type u), f α) (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
       (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} f _inst_5) (g β)
          (g α → g (prod.{v v} α β))
          (λ (x : g β) (x_1 : g α),
             @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)
               (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
                  (@prod.mk.{v v} α β)
                  x_1)
               x)
          b)
       a)
    (@has_seq.seq.{u w} f (@applicative.to_has_seq.{u w} f _inst_5) (g α) (g (prod.{v v} α β))
       (@functor.map.{u w} (λ (α : Type u), f α) (@applicative.to_functor.{u w} f _inst_5) (g β)
          (g α → g (prod.{v v} α β))
          (λ (x : g β),
             @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β)
               (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
                  (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
                  x))
          b)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β
⊢ @eq.{u+1} (g β → g α → g (prod.{v v} α β))
    (λ (x : g β) (x_1 : g α),
       @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)
         (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
            (@prod.mk.{v v} α β)
            x_1)
         x)
    (λ (x : g β),
       @has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β)
         (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
            (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β,
x : g β,
x : g α
⊢ @eq.{u+1} (g (prod.{v v} α β))
    (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) β (prod.{v v} α β)
       (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) α (β → prod.{v v} α β)
          (@prod.mk.{v v} α β)
          x)
       x)
    (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β)
       (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
          (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
          x)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : Type u → Type w,
g : Type v → Type u,
_inst_5 : applicative.{u w} f,
_inst_6 : applicative.{v u} g,
_inst_7 : @is_comm_applicative.{u w} f _inst_5,
_inst_8 : @is_comm_applicative.{v u} g _inst_6,
α β : Type v,
a : functor.comp.{u v w} f g α,
b : functor.comp.{u v w} f g β,
x : g β,
x : g α
⊢ @eq.{u+1} (g (prod.{v v} α β))
    (@has_seq.seq.{v u} (λ (α : Type v), g α) (@applicative.to_has_seq.{v u} (λ (α : Type v), g α) _inst_6) α
       (prod.{v v} α β)
       (@functor.map.{v u} (λ (α : Type v), g α) (@applicative.to_functor.{v u} (λ (α : Type v), g α) _inst_6) β
          (α → prod.{v v} α β)
          (@flip.{v+1 v+1 v+1} α β (prod.{v v} α β) (@prod.mk.{v v} α β))
          x)
       x)
    (@has_seq.seq.{v u} g (@applicative.to_has_seq.{v u} g _inst_6) α (prod.{v v} α β)
       (@functor.map.{v u} g (@applicative.to_functor.{v u} g _inst_6) β (α → prod.{v v} α β)
          (λ (b : β) (a : α), @prod.mk.{v v} α β a b)
          x)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  end comp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  open functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  @[functor_norm]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplifier attribute'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  lemma comp.seq_mk {α β : Type w}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    {f : Type u → Type v} {g : Type w → Type u}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    [applicative f] [applicative g]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type w → Type u) → Type (max (w+1) u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    (h : f (g (α → β))) (x : f (g α)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type w → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type w → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    comp.mk h &lt;*&gt; comp.mk x = comp.mk (has_seq.seq &lt;$&gt; h &lt;*&gt; x) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='f (g (α → β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type w → Type v} [c : has_seq.{w v} f] {α β : Type w}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='f (g α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_seq.{u v} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='f (g (α → β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_seq.{u v} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='f (g α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  instance {α} [has_one α] [has_mul α] : applicative (const α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_2 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  { pure := λ β x, (1 : α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    seq := λ β γ f x, (f * x : α) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.const.{u_1 u_2} α (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.const.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='functor.const.{u_1 u_2} α (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.const.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  instance {α} [monoid α] : is_lawful_applicative (const α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_2 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  by refine { .. }; intros; simp [mul_assoc]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a b) c) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : monoid.{?l_1} α
⊢ @is_lawful_applicative.{?l_2 ?l_1} (functor.const.{?l_1 ?l_2} α)
    (@functor.const.applicative.{?l_1 ?l_2} α (@monoid.to_has_one.{?l_1} α _inst_1)
       (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : monoid.{?l_1} α
⊢ @is_lawful_applicative.{?l_2 ?l_1} (functor.const.{?l_1 ?l_2} α)
    (@functor.const.applicative.{?l_1 ?l_2} α (@monoid.to_has_one.{?l_1} α _inst_1)
       (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  instance {α} [has_zero α] [has_add α] : applicative (add_const α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.add_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_2 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  { pure := λ β x, (0 : α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    seq := λ β γ f x, (f + x : α) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.add_const.{u_1 u_2} α (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.add_const.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='functor.add_const.{u_1 u_2} α (β → γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_add.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='functor.add_const.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  instance {α} [add_monoid α] : is_lawful_applicative (add_const α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='add_monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.add_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (f : Type u → Type v) [_inst_1 : applicative.{u v} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_2 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  by refine { .. }; intros; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : add_monoid.{?l_1} α
⊢ @is_lawful_applicative.{?l_2 ?l_1} (functor.add_const.{?l_1 ?l_2} α)
    (@functor.add_const.applicative.{?l_1 ?l_2} α (@add_monoid.to_has_zero.{?l_1} α _inst_1)
       (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font></pre>
</body>