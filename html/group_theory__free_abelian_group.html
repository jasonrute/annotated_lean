<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Kenny Lau. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Kenny Lau</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Free abelian groups as abelianization of free groups.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import algebra.pi_instances</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import group_theory.free_group</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import group_theory.abelianization</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  variables (α : Type u)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  def free_abelian_group : Type u :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  additive $ abelianization $ free_group α</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='abelianization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_1 : group.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title=' The free group over a type, i.e. the words formed by the elements of the type and their formal
inverses, quotient by one step reduction.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  instance : add_comm_group (free_abelian_group α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  @additive.add_comm_group _ $ abelianization.comm_group _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='additive.add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='abelianization.comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_group.{u} α], add_comm_group.{u} (additive.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : group.{u} α], comm_group.{u} (@abelianization.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  instance : inhabited (free_abelian_group α) := ⟨0⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  variable {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  namespace free_abelian_group</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  def of (x : α) : free_abelian_group α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  abelianization.of $ free_group.of x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='abelianization.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : group.{u} α], α → @abelianization.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' `of x` is the canonical injection from the type to the free group over that type by sending each
element to the equivalence class of the letter that is the element.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  def lift {β : Type v} [add_comm_group β] (f : α → β) (x : free_abelian_group α) : β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  @abelianization.lift _ _ (multiplicative β) _ (@free_group.to_group _ (multiplicative β) _ f) _ x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='abelianization.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_group.to_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 383, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : group.{u} α] {β : Type v} [_inst_2 : comm_group.{v} β] (f : α → β) [_inst_3 : @is_group_hom.{u v} α β _inst_1 (@comm_group.to_group.{v} β _inst_2) f], @abelianization.{u} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : group.{v} β], (α → β) → free_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title=' If `β` is a group, then any function from `α` to `β`
extends uniquely to a group homomorphism from
the free group over `α` to `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  namespace lift</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  variables {β : Type v} [add_comm_group β] (f : α → β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  open free_abelian_group</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  instance is_add_group_hom : is_add_group_hom (lift f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  { map_add := λ x y, @is_mul_hom.map_mul _ (multiplicative β) _ _ _ (abelianization.lift.is_group_hom _).to_is_mul_hom x y }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_mul_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='abelianization.lift.is_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_group_hom.to_is_mul_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : has_mul.{u_1} α] [_inst_2 : has_mul.{u_2} β] (f : α → β) [c : @is_mul_hom.{u_1 u_2} α β _inst_1 _inst_2 f] (x y : α), @eq.{u_2+1} β (f (@has_mul.mul.{u_1} α _inst_1 x y)) (@has_mul.mul.{u_2} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : group.{u} α] {β : Type v} [_inst_2 : comm_group.{v} β] (f : α → β) [_inst_3 : @is_group_hom.{u v} α β _inst_1 (@comm_group.to_group.{v} β _inst_2) f], @is_group_hom.{u v} (@abelianization.{u} α _inst_1) β (@quotient_group.group.{u} α _inst_1 (@commutator.{u} α _inst_1) (@commutator.normal_subgroup.{u} α _inst_1)) (@comm_group.to_group.{v} β _inst_2) (@abelianization.lift.{u v} α _inst_1 β _inst_2 f _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : group.{u} α] [_inst_2 : group.{v} β] (f : α → β) [c : @is_group_hom.{u v} α β _inst_1 _inst_2 f], @is_mul_hom.{u v} α β (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α (@group.to_monoid.{u} α _inst_1))) (@semigroup.to_has_mul.{v} β (@monoid.to_semigroup.{v} β (@group.to_monoid.{v} β _inst_2))) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  @[simp] protected lemma add (x y : free_abelian_group α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    lift f (x + y) = lift f x + lift f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  is_add_hom.map_add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_add.{u} α] [_inst_2 : has_add.{v} β] (f : α → β) [c : @is_add_hom.{u v} α β _inst_1 _inst_2 f] (x y : α), @eq.{v+1} β (f (@has_add.add.{u} α _inst_1 x y)) (@has_add.add.{v} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @[simp] protected lemma neg (x : free_abelian_group α) : lift f (-x) = -lift f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  is_add_group_hom.map_neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_group_hom.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β] (f : α → β) [_inst_3 : @is_add_group_hom.{u v} α β _inst_1 _inst_2 f] (a : α), @eq.{v+1} β (f (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  @[simp] protected lemma sub (x y : free_abelian_group α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    lift f (x - y) = lift f x - lift f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  by simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f : α → β,
x y : free_abelian_group.{u} α
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} α β _inst_1 f
       (@has_sub.sub.{u} (free_abelian_group.{u} α)
          (@add_group_has_sub.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y))
    (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β _inst_1))
       (@free_abelian_group.lift.{u v} α β _inst_1 f x)
       (@free_abelian_group.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f : α → β,
x y : free_abelian_group.{u} α
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} α β _inst_1 f
       (@has_sub.sub.{u} (free_abelian_group.{u} α)
          (@add_group_has_sub.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y))
    (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β _inst_1))
       (@free_abelian_group.lift.{u v} α β _inst_1 f x)
       (@free_abelian_group.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  @[simp] protected lemma zero : lift f 0 = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  is_add_group_hom.map_zero _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_group_hom.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β] (f : α → β) [_inst_3 : @is_add_group_hom.{u v} α β _inst_1 _inst_2 f], @eq.{v+1} β (f (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  @[simp] protected lemma of (x : α) : lift f (of x) = f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  by unfold of; unfold lift; simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f : α → β,
x : α
⊢ @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f : α → β,
x : α
⊢ @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  protected theorem unique (g : free_abelian_group α → β) [is_add_group_hom g]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    (hg : ∀ x, g (of x) = f x) {x} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    g x = lift f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  @abelianization.lift.unique (free_group α) _ (multiplicative β) _ _ _ g</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='abelianization.lift.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : group.{u} α] {β : Type v} [_inst_2 : comm_group.{v} β] (f : α → β) [_inst_3 : @is_group_hom.{u v} α β _inst_1 (@comm_group.to_group.{v} β _inst_2) f] (g : @abelianization.{u} α _inst_1 → β) [_inst_4 : @is_group_hom.{u v} (@abelianization.{u} α _inst_1) β (@comm_group.to_group.{u} (@abelianization.{u} α _inst_1) (@abelianization.comm_group.{u} α _inst_1)) (@comm_group.to_group.{v} β _inst_2) g], (∀ (x : α), @eq.{v+1} β (g (@abelianization.of.{u} α _inst_1 x)) (f x)) → ∀ {x : @abelianization.{u} α _inst_1}, @eq.{v+1} β (g x) (@abelianization.lift.{u v} α _inst_1 β _inst_2 f _inst_3 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title=' The free group over a type, i.e. the words formed by the elements of the type and their formal
inverses, quotient by one step reduction.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    { map_mul := λ x y, is_add_hom.map_add g x y } (λ x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_add_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@abelianization.{u} (free_group.{u} α) (@free_group.group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@abelianization.{u} (free_group.{u} α) (@free_group.group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_add.{u} α] [_inst_2 : has_add.{v} β] (f : α → β) [c : @is_add_hom.{u v} α β _inst_1 _inst_2 f] (x y : α), @eq.{v+1} β (f (@has_add.add.{u} α _inst_1 x y)) (@has_add.add.{v} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@abelianization.{u} (free_group.{u} α) (@free_group.group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@abelianization.{u} (free_group.{u} α) (@free_group.group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    @free_group.to_group.unique α (multiplicative β) _ _ (g ∘ abelianization.of)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_group.to_group.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='abelianization.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 407, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : group.{v} β] {f : α → β} (g : free_group.{u} α → β) [_inst_2 : @is_group_hom.{u v} (free_group.{u} α) β (@free_group.group.{u} α) _inst_1 g], (∀ (x : α), @eq.{v+1} β (g (@free_group.of.{u} α x)) (f x)) → ∀ {x : free_group.{u} α}, @eq.{v+1} β (g x) (@free_group.to_group.{u v} α β _inst_1 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : group.{u} α], α → @abelianization.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64      { map_mul := λ m n, is_add_hom.map_add g (abelianization.of m) (abelianization.of n) } hg _) _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_add_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abelianization.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='abelianization.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_add.{u} α] [_inst_2 : has_add.{v} β] (f : α → β) [c : @is_add_hom.{u v} α β _inst_1 _inst_2 f] (x y : α), @eq.{v+1} β (f (@has_add.add.{u} α _inst_1 x y)) (@has_add.add.{v} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : group.{u} α], α → @abelianization.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : group.{u} α], α → @abelianization.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (x : α), @eq.{v+1} β (g (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  protected theorem ext (g h : free_abelian_group α → β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    [is_add_group_hom g] [is_add_group_hom h]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    (H : ∀ x, g (of x) = h (of x)) {x} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    g x = h x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  (lift.unique (g ∘ of) g (λ _, rfl)).trans $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (g : free_abelian_group.{u} α → β) [_inst_2 : @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) g], (∀ (x : α), @eq.{v+1} β (g (@free_abelian_group.of.{u} α x)) (f x)) → ∀ {x : free_abelian_group.{u} α}, @eq.{v+1} β (g x) (@free_abelian_group.lift.{u v} α β _inst_1 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {a b c : α}, @eq.{v+1} α a b → @eq.{v+1} α b c → @eq.{v+1} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  eq.symm $ lift.unique _ _ $ λ x, eq.symm $ H x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group.lift.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (g : free_abelian_group.{u} α → β) [_inst_2 : @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) g], (∀ (x : α), @eq.{v+1} β (g (@free_abelian_group.of.{u} α x)) (f x)) → ∀ {x : free_abelian_group.{u} α}, @eq.{v+1} β (g x) (@free_abelian_group.lift.{u v} α β _inst_1 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : α), @eq.{v+1} β (g (@free_abelian_group.of.{u} α x)) (h (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  lemma map_hom {α β γ} [add_comm_group β] [add_comm_group γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    (a : free_abelian_group α) (f : α → β) (g : β → γ) [is_add_group_hom g] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3} [_inst_1 : add_group.{u_2} α] [_inst_2 : add_group.{u_3} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    g (a.lift f) = a.lift (g ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3} [_inst_1 : add_comm_group.{u_3} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  show (g ∘ lift f) a = a.lift (g ∘ f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3} [_inst_1 : add_comm_group.{u_3} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g
⊢ @eq.{u_3+1} γ
    (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
       a)
    (@free_abelian_group.lift.{u_1 u_3} α γ _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    apply @lift.unique,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.lift.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} [_inst_1 : add_comm_group.{u_3} β] (f : α → β) (g : free_abelian_group.{u_1} α → β) [_inst_2 : @is_add_group_hom.{u_1 u_3} (free_abelian_group.{u_1} α) β (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α) (free_abelian_group.add_comm_group.{u_1} α)) (@add_comm_group.to_add_group.{u_3} β _inst_1) g], (∀ (x : α), @eq.{u_3+1} β (g (@free_abelian_group.of.{u_1} α x)) (f x)) → ∀ {x : free_abelian_group.{u_1} α}, @eq.{u_3+1} β (g x) (@free_abelian_group.lift.{u_1 u_3} α β _inst_1 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g
⊢ @eq.{u_3+1} γ
    (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
       a)
    (@free_abelian_group.lift.{u_1 u_3} α γ _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g
⊢ ∀ (x : α),
    @eq.{u_3+1} γ
      (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
         (@free_abelian_group.of.{u_1} α x))
      (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g
⊢ ∀ (x : α),
    @eq.{u_3+1} γ
      (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
         (@free_abelian_group.of.{u_1} α x))
      (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g,
a : α
⊢ @eq.{u_3+1} γ
    (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
       (@free_abelian_group.of.{u_1} α a))
    (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    simp only [(∘), lift.of]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β) (x : α), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@free_abelian_group.of.{?l_1} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_2 : add_comm_group.{u_2} β,
_inst_3 : add_comm_group.{u_3} γ,
a : free_abelian_group.{u_1} α,
f : α → β,
g : β → γ,
_inst_4 :
  @is_add_group_hom.{u_2 u_3} β γ (@add_comm_group.to_add_group.{u_2} β _inst_2)
    (@add_comm_group.to_add_group.{u_3} γ _inst_3)
    g,
a : α
⊢ @eq.{u_3+1} γ
    (@function.comp.{u_1+1 u_2+1 u_3+1} (free_abelian_group.{u_1} α) β γ g
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_2 f)
       (@free_abelian_group.of.{u_1} α a))
    (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  def universal : (α → β) ≃ { f : free_abelian_group α → β // is_add_group_hom f } :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type (max u v) → Type (max u v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  { to_fun := λ f, ⟨_, lift.is_add_group_hom f⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_abelian_group.lift.is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β), @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) (@free_abelian_group.lift.{u v} α β _inst_1 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    inv_fun := λ f, f.1 ∘ of,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β) (λ (f : free_abelian_group.{u} α → β), @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β) (λ (f : free_abelian_group.{u} α → β), @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u v)} {p : α → Prop}, @subtype.{(max (u+1) (v+1))} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    left_inv := λ f, funext $ λ x, lift.of f x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    right_inv := λ f, subtype.eq $ funext $ λ x, eq.symm $ by letI := f.2; from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β) (λ (f : free_abelian_group.{u} α → β), @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a1 a2 : @subtype.{u+1} α (λ (x : α), p x)}, @eq.{u+1} α (@subtype.val.{u+1} α (λ (x : α), p x) a1) (@subtype.val.{u+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u+1))} (@subtype.{u+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, @eq.{u} α a b → @eq.{u} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β) (λ (f : free_abelian_group.{u} α → β), @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f :
  @subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
    (λ (f : free_abelian_group.{u} α → β),
       @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
         (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
         (@add_comm_group.to_add_group.{v} β _inst_1)
         f),
x : free_abelian_group.{u} α
⊢ @eq.{v+1} β
    (@subtype.val.{(max u v)+1} (free_abelian_group.{u} α → β)
       (λ (x : free_abelian_group.{u} α → β),
          @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
            (@add_comm_group.to_add_group.{v} β _inst_1)
            x)
       f
       x)
    (@subtype.val.{(max u v)+1} (free_abelian_group.{u} α → β)
       (λ (x : free_abelian_group.{u} α → β),
          @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
            (@add_comm_group.to_add_group.{v} β _inst_1)
            x)
       ((λ (f : α → β),
           @subtype.mk.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
             (λ (f : free_abelian_group.{u} α → β),
                @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α))
                  (@add_comm_group.to_add_group.{v} β _inst_1)
                  f)
             (@free_abelian_group.lift.{u v} α β _inst_1 f)
             (@free_abelian_group.lift.is_add_group_hom.{u v} α β _inst_1 f))
          ((λ
            (f :
              @subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
                (λ (f : free_abelian_group.{u} α → β),
                   @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α))
                     (@add_comm_group.to_add_group.{v} β _inst_1)
                     f)),
              @function.comp.{u+1 u+1 v+1} α (free_abelian_group.{u} α) β
                (@subtype.val.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
                   (λ (f : free_abelian_group.{u} α → β),
                      @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α))
                        (@add_comm_group.to_add_group.{v} β _inst_1)
                        f)
                   f)
                (@free_abelian_group.of.{u} α))
             f))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      lift.unique _ _ (λ _, rfl) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_abelian_group.lift.unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (g : free_abelian_group.{u} α → β) [_inst_2 : @is_add_group_hom.{u v} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{v} β _inst_1) g], (∀ (x : α), @eq.{v+1} β (g (@free_abelian_group.of.{u} α x)) (f x)) → ∀ {x : free_abelian_group.{u} α}, @eq.{v+1} β (g x) (@free_abelian_group.lift.{u v} α β _inst_1 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : add_comm_group.{v} β,
f :
  @subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
    (λ (f : free_abelian_group.{u} α → β),
       @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
         (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
         (@add_comm_group.to_add_group.{v} β _inst_1)
         f),
x : free_abelian_group.{u} α
⊢ @eq.{v+1} β
    (@subtype.val.{(max u v)+1} (free_abelian_group.{u} α → β)
       (λ (x : free_abelian_group.{u} α → β),
          @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
            (@add_comm_group.to_add_group.{v} β _inst_1)
            x)
       f
       x)
    (@subtype.val.{(max u v)+1} (free_abelian_group.{u} α → β)
       (λ (x : free_abelian_group.{u} α → β),
          @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))
            (@add_comm_group.to_add_group.{v} β _inst_1)
            x)
       ((λ (f : α → β),
           @subtype.mk.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
             (λ (f : free_abelian_group.{u} α → β),
                @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α))
                  (@add_comm_group.to_add_group.{v} β _inst_1)
                  f)
             (@free_abelian_group.lift.{u v} α β _inst_1 f)
             (@free_abelian_group.lift.is_add_group_hom.{u v} α β _inst_1 f))
          ((λ
            (f :
              @subtype.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
                (λ (f : free_abelian_group.{u} α → β),
                   @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α))
                     (@add_comm_group.to_add_group.{v} β _inst_1)
                     f)),
              @function.comp.{u+1 u+1 v+1} α (free_abelian_group.{u} α) β
                (@subtype.val.{(max (u+1) (v+1))} (free_abelian_group.{u} α → β)
                   (λ (f : free_abelian_group.{u} α → β),
                      @is_add_group_hom.{u v} (free_abelian_group.{u} α) β
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α))
                        (@add_comm_group.to_add_group.{v} β _inst_1)
                        f)
                   f)
                (@free_abelian_group.of.{u} α))
             f))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  end lift</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  local attribute [instance] quotient_group.left_rel normal_subgroup.to_is_subgroup</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='quotient_group.left_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='normal_subgroup.to_is_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/coset.lean&#x27;, &#x27;line&#x27;: 146, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : group.{u_1} α] (s : set.{u_1} α) [_inst_2 : @is_subgroup.{u_1} α _inst_1 s], setoid.{u_1+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] (s : set.{u_1} α) [c : @normal_subgroup.{u_1} α _inst_1 s], @is_subgroup.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  @[elab_as_eliminator]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated as f were an eliminator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  protected theorem induction_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    {C : free_abelian_group α → Prop}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    (z : free_abelian_group α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    (C0 : C 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    (C1 : ∀ x, C $ of x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    (Cn : ∀ x, C (of x) → C (-of x))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  quotient.induction_on z $ λ x, quot.induction_on x $ λ L,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : setoid.{u+1} α] {β : @quotient.{u+1} α s → Prop} (q : @quotient.{u+1} α s), (∀ (a : α), β (@quotient.mk.{u+1} α s a)) → β q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {r : α → α → Prop} {β : @quot.{u+1} α r → Prop} (q : @quot.{u+1} α r), (∀ (a : α), β (@quot.mk.{u+1} α r a)) → β q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='list.{u} (prod.{u 0} α bool)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  list.rec_on L C0 $ λ ⟨x, b⟩ tl ih,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {T : Type u} {C : list.{u} T → Prop} (n : list.{u} T), C (@list.nil.{u} T) → (∀ (hd : T) (tl : list.{u} T), C tl → C (@list.cons.{u} T hd tl)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u} (prod.{u 0} α bool)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='prod.{u 0} α bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u} (prod.{u 0} α bool)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@quotient.mk.{u+1} (free_group.{u} α) (@quotient_group.left_rel.{u} (free_group.{u} α) (@free_group.group.{u} α) (@commutator.{u} (free_group.{u} α) (@free_group.group.{u} α)) (@abelianization._proof_1.{u} (free_group.{u} α) (@free_group.group.{u} α))) (@quot.mk.{u+1} (list.{u} (prod.{u 0} α bool)) (@free_group.red.step.{u} α) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  bool.rec_on b (Cp _ _ (Cn _ (C1 x)) ih) (Cp _ _ (C1 x) ih)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='bool.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Cp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='Cn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Cp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : bool → Prop} (n : bool), C bool.ff → C bool.tt → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (x : α), C (@free_abelian_group.of.{u} α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C (@quotient.mk.{u+1} (free_group.{u} α) (@quotient_group.left_rel.{u} (free_group.{u} α) (@free_group.group.{u} α) (@commutator.{u} (free_group.{u} α) (@free_group.group.{u} α)) (@abelianization._proof_1.{u} (free_group.{u} α) (@free_group.group.{u} α))) (@quot.mk.{u+1} (list.{u} (prod.{u 0} α bool)) (@free_group.red.step.{u} α) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (x : α), C (@free_abelian_group.of.{u} α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C (@quotient.mk.{u+1} (free_group.{u} α) (@quotient_group.left_rel.{u} (free_group.{u} α) (@free_group.group.{u} α) (@commutator.{u} (free_group.{u} α) (@free_group.group.{u} α)) (@abelianization._proof_1.{u} (free_group.{u} α) (@free_group.group.{u} α))) (@quot.mk.{u+1} (list.{u} (prod.{u 0} α bool)) (@free_group.red.step.{u} α) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α
⊢ @eq.{u+1} α
    (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1 L2)
       L3)
    (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  theorem lift.add&#x27; {α β} [add_comm_group β] (a : free_abelian_group α) (f g : α → β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    a.lift (f + g) = (a.lift f) + (a.lift g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)} [c : has_add.{(max u_1 u_2)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       a)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f a)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    refine free_abelian_group.induction_on a _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : free_abelian_group.{u_1} α → Prop} (z : free_abelian_group.{u_1} α), C (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α) (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α) (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α) (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α) (free_abelian_group.add_comm_group.{u_1} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u_1} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u_1} α x) → C (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α) (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α) (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α) (free_abelian_group.add_comm_group.{u_1} α))) (@free_abelian_group.of.{u_1} α x))) → (∀ (x y : free_abelian_group.{u_1} α), C x → C y → C (@has_add.add.{u_1} (free_abelian_group.{u_1} α) (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α) (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α) (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α) (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α) (free_abelian_group.add_comm_group.{u_1} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       a)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f a)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
          (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α))))))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α))))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α)))))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    { simp only [lift.zero, zero_add] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='free_abelian_group.lift.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@has_zero.zero.{?l_1} (free_abelian_group.{?l_1} α) (@add_monoid.to_has_zero.{?l_1} (free_abelian_group.{?l_1} α) (@add_group.to_add_monoid.{?l_1} (free_abelian_group.{?l_1} α) (@add_comm_group.to_add_group.{?l_1} (free_abelian_group.{?l_1} α) (free_abelian_group.add_comm_group.{?l_1} α)))))) (@has_zero.zero.{?l_2} β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_monoid.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α _inst_1)) (@has_zero.zero.{?l_1} α (@add_monoid.to_has_zero.{?l_1} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
          (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α))))))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α))))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α)))))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
          (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α))))))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α))))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_zero.zero.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_has_zero.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    { assume x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x : α
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@free_abelian_group.of.{u_1} α x))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112      simp only [lift.of, pi.add_apply] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pi.add_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β) (x : α), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@free_abelian_group.of.{?l_1} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {I : Type ?l_1} {f : I → Type ?l_2} (x y : Π (i : I), f i) (i : I) [_inst_1 : Π (i : I), has_add.{?l_2} (f i)], @eq.{?l_2+1} (f i) (@has_add.add.{(max ?l_1 ?l_2)} (Π (i : I), f i) (@pi.has_add.{?l_1 ?l_2} I (λ (i : I), f i) (λ (i : I), _inst_1 i)) x y i) (@has_add.add.{?l_2} (f i) (_inst_1 i) (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x : α
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@free_abelian_group.of.{u_1} α x))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    { assume x h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))

α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x : α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@free_abelian_group.of.{u_1} α x))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x))) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
            (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                  (free_abelian_group.add_comm_group.{u_1} α)))
            (@free_abelian_group.of.{u_1} α x)))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x)))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
               (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                  (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                     (free_abelian_group.add_comm_group.{u_1} α)))
               (@free_abelian_group.of.{u_1} α x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x : α,
h :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@free_abelian_group.of.{u_1} α x))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
          (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                (free_abelian_group.add_comm_group.{u_1} α)))
          (@free_abelian_group.of.{u_1} α x)))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α)))
             (@free_abelian_group.of.{u_1} α x)))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α)))
             (@free_abelian_group.of.{u_1} α x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114      simp only [lift.neg, lift.of, pi.add_apply, neg_add] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pi.add_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β) (x : free_abelian_group.{?l_1} α), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@has_neg.neg.{?l_1} (free_abelian_group.{?l_1} α) (@add_group.to_has_neg.{?l_1} (free_abelian_group.{?l_1} α) (@add_comm_group.to_add_group.{?l_1} (free_abelian_group.{?l_1} α) (free_abelian_group.add_comm_group.{?l_1} α))) x)) (@has_neg.neg.{?l_2} β (@add_group.to_has_neg.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_1)) (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β) (x : α), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@free_abelian_group.of.{?l_1} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {I : Type ?l_1} {f : I → Type ?l_2} (x y : Π (i : I), f i) (i : I) [_inst_1 : Π (i : I), has_add.{?l_2} (f i)], @eq.{?l_2+1} (f i) (@has_add.add.{(max ?l_1 ?l_2)} (Π (i : I), f i) (@pi.has_add.{?l_1 ?l_2} I (λ (i : I), f i) (λ (i : I), _inst_1 i)) x y i) (@has_add.add.{?l_2} (f i) (_inst_1 i) (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_comm_group.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)))) a b)) (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)))) (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) a) (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x : α,
h :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@free_abelian_group.of.{u_1} α x))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f (@free_abelian_group.of.{u_1} α x))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g (@free_abelian_group.of.{u_1} α x)))
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
          (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                (free_abelian_group.add_comm_group.{u_1} α)))
          (@free_abelian_group.of.{u_1} α x)))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α)))
             (@free_abelian_group.of.{u_1} α x)))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_neg.neg.{u_1} (free_abelian_group.{u_1} α)
             (@add_group.to_has_neg.{u_1} (free_abelian_group.{u_1} α)
                (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                   (free_abelian_group.add_comm_group.{u_1} α)))
             (@free_abelian_group.of.{u_1} α x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    { assume x y hx hy,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β
⊢ ∀ (x y : free_abelian_group.{u_1} α),
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         x)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         y)
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)) →
    @eq.{u_2+1} β
      (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
         (@has_add.add.{(max u_1 u_2)} (α → β)
            (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
               (λ (i : α),
                  @add_semigroup.to_has_add.{u_2} β
                    (@add_monoid.to_add_semigroup.{u_2} β
                       (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
            f
            g)
         (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
            (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
               (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                  (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                     (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                        (free_abelian_group.add_comm_group.{u_1} α)))))
            x
            y))
      (@has_add.add.{u_2} β
         (@add_semigroup.to_has_add.{u_2} β
            (@add_monoid.to_add_semigroup.{u_2} β
               (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y))
         (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
            (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
               (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                  (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                     (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                        (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                           (free_abelian_group.add_comm_group.{u_1} α)))))
               x
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x y : free_abelian_group.{u_1} α,
hx :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       x)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)),
hy :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       y)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y))
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
          (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α)))))
          x
          y))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
             (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                   (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                      (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                         (free_abelian_group.add_comm_group.{u_1} α)))))
             x
             y))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
             (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                   (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                      (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                         (free_abelian_group.add_comm_group.{u_1} α)))))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116      simp only [lift.add, hx, hy],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β] (f : α → β) (x y : free_abelian_group.{?l_1} α), @eq.{?l_2+1} β (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f (@has_add.add.{?l_1} (free_abelian_group.{?l_1} α) (@add_semigroup.to_has_add.{?l_1} (free_abelian_group.{?l_1} α) (@add_monoid.to_add_semigroup.{?l_1} (free_abelian_group.{?l_1} α) (@add_group.to_add_monoid.{?l_1} (free_abelian_group.{?l_1} α) (@add_comm_group.to_add_group.{?l_1} (free_abelian_group.{?l_1} α) (free_abelian_group.add_comm_group.{?l_1} α))))) x y)) (@has_add.add.{?l_2} β (@add_semigroup.to_has_add.{?l_2} β (@add_monoid.to_add_semigroup.{?l_2} β (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_1)))) (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f x) (@free_abelian_group.lift.{?l_1 ?l_2} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} β (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 (@has_add.add.{(max u_1 u_2)} (α → β) (@pi.has_add.{u_1 u_2} α (λ (a : α), β) (λ (i : α), @add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))) f g) x) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} β (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 (@has_add.add.{(max u_1 u_2)} (α → β) (@pi.has_add.{u_1 u_2} α (λ (a : α), β) (λ (i : α), @add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))) f g) y) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x y : free_abelian_group.{u_1} α,
hx :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       x)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)),
hy :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       y)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y))
⊢ @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
          (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
             (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                   (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                      (free_abelian_group.add_comm_group.{u_1} α)))))
          x
          y))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f
          (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
             (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                   (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                      (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                         (free_abelian_group.add_comm_group.{u_1} α)))))
             x
             y))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g
          (@has_add.add.{u_1} (free_abelian_group.{u_1} α)
             (@add_semigroup.to_has_add.{u_1} (free_abelian_group.{u_1} α)
                (@add_monoid.to_add_semigroup.{u_1} (free_abelian_group.{u_1} α)
                   (@add_group.to_add_monoid.{u_1} (free_abelian_group.{u_1} α)
                      (@add_comm_group.to_add_group.{u_1} (free_abelian_group.{u_1} α)
                         (free_abelian_group.add_comm_group.{u_1} α)))))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x y : free_abelian_group.{u_1} α,
hx :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       x)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)),
hy :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       y)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y))
⊢ @eq.{u_2+1} β
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      ac_refl }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1294, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `ac_reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ac_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : add_comm_group.{u_2} β,
a : free_abelian_group.{u_1} α,
f g : α → β,
x y : free_abelian_group.{u_1} α,
hx :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       x)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)),
hy :
  @eq.{u_2+1} β
    (@free_abelian_group.lift.{u_1 u_2} α β _inst_1
       (@has_add.add.{(max u_1 u_2)} (α → β)
          (@pi.has_add.{u_1 u_2} α (λ (a : α), β)
             (λ (i : α),
                @add_semigroup.to_has_add.{u_2} β
                  (@add_monoid.to_add_semigroup.{u_2} β
                     (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))))
          f
          g)
       y)
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
       (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y))
⊢ @eq.{u_2+1} β
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)))
    (@has_add.add.{u_2} β
       (@add_semigroup.to_has_add.{u_2} β
          (@add_monoid.to_add_semigroup.{u_2} β
             (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f y))
       (@has_add.add.{u_2} β
          (@add_semigroup.to_has_add.{u_2} β
             (@add_monoid.to_add_semigroup.{u_2} β
                (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g x)
          (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  instance is_add_group_hom_lift&#x27; {α} (β) [add_comm_group β] (a : free_abelian_group α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    is_add_group_hom (λf, (a.lift f : β)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β], (α → β) → free_abelian_group.{u_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  { map_add := λ f g, lift.add&#x27; a f g }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.add&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ (i : α), (λ (a : α), β) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : α), (λ (a : α), β) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group.{u_2} β] (a : free_abelian_group.{u_1} α) (f g : α → β), @eq.{u_2+1} β (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 (@has_add.add.{(max u_1 u_2)} (α → β) (@pi.has_add.{u_1 u_2} α (λ (a : α), β) (λ (i : α), @add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1))))) f g) a) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_1)))) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 f a) (@free_abelian_group.lift.{u_1 u_2} α β _inst_1 g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : α), (λ (a : α), β) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : α), (λ (a : α), β) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  variables {β : Type u}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  instance : monad free_abelian_group.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  { pure := λ α, of,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    bind := λ α β x f, lift f x }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  @[elab_as_eliminator]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated as f were an eliminator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  protected theorem induction_on&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    {C : free_abelian_group α → Prop}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    (z : free_abelian_group α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    (C0 : C 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    (C1 : ∀ x, C $ pure x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    (Cn : ∀ x, C (pure x) → C (-pure x))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  free_abelian_group.induction_on z C0 C1 Cn Cp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Cn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Cp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  @[simp] lemma map_pure (f : α → β) (x : α) : f &lt;$&gt; (pure x : free_abelian_group α) = pure (f x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  lift.of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  @[simp] lemma map_zero (f : α → β) : f &lt;$&gt; (0 : free_abelian_group α) = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  lift.zero (of ∘ f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  @[simp] lemma map_add (f : α → β) (x y : free_abelian_group α) : f &lt;$&gt; (x + y) = f &lt;$&gt; x + f &lt;$&gt; y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  lift.add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  @[simp] lemma map_neg (f : α → β) (x : free_abelian_group α) : f &lt;$&gt; (-x) = -(f &lt;$&gt; x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  lift.neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  @[simp] lemma map_sub (f : α → β) (x y : free_abelian_group α) : f &lt;$&gt; (x - y) = f &lt;$&gt; x - f &lt;$&gt; y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  lift.sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_sub.sub.{u} (free_abelian_group.{u} α) (@add_group_has_sub.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  @[simp] lemma pure_bind (f : α → free_abelian_group β) (x) : pure x &gt;&gt;= f = f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  lift.of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[simp] lemma zero_bind (f : α → free_abelian_group β) : 0 &gt;&gt;= f = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  lift.zero f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  @[simp] lemma add_bind (f : α → free_abelian_group β) (x y : free_abelian_group α) : x + y &gt;&gt;= f = (x &gt;&gt;= f) + (y &gt;&gt;= f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  lift.add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  @[simp] lemma neg_bind (f : α → free_abelian_group β) (x : free_abelian_group α) : -x &gt;&gt;= f = -(x &gt;&gt;= f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  lift.neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  @[simp] lemma sub_bind (f : α → free_abelian_group β) (x y : free_abelian_group α) : x - y &gt;&gt;= f = (x &gt;&gt;= f) - (y &gt;&gt;= f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {m : Type u → Type u} [c : has_bind.{u u} m] {α β : Type u}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  lift.sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_sub.sub.{u} (free_abelian_group.{u} α) (@add_group_has_sub.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  @[simp] lemma pure_seq (f : α → β) (x : free_abelian_group α) : pure f &lt;*&gt; x = f &lt;$&gt; x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  pure_bind _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.pure_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) f) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  @[simp] lemma zero_seq (x : free_abelian_group α) : (0 : free_abelian_group (α → β)) &lt;*&gt; x = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  zero_bind _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.zero_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 158, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) f) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  @[simp] lemma add_seq (f g : free_abelian_group (α → β)) (x : free_abelian_group α) : f + g &lt;*&gt; x = (f &lt;*&gt; x) + (g &lt;*&gt; x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  add_bind _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.add_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 161, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y) f) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  @[simp] lemma neg_seq (f : free_abelian_group (α → β)) (x : free_abelian_group α) : -f &lt;*&gt; x = -(f &lt;*&gt; x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  neg_bind _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.neg_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 164, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x) f) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  @[simp] lemma sub_seq (f g : free_abelian_group (α → β)) (x : free_abelian_group α) : f - g &lt;*&gt; x = (f &lt;*&gt; x) - (g &lt;*&gt; x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  sub_bind _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.sub_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_sub.sub.{u} (free_abelian_group.{u} α) (@add_group_has_sub.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y) f) (@has_sub.sub.{u} (free_abelian_group.{u} β) (@add_group_has_sub.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  instance is_add_group_hom_seq (f : free_abelian_group (α → β)) : is_add_group_hom ((&lt;*&gt;) f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  { map_add := λ x y, show lift (&lt;$&gt; (x+y)) _ = _, by simp only [map_add]; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='free_abelian_group.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type ?l_1} (f : α → β) (x y : free_abelian_group.{?l_1} α), @eq.{?l_1+1} (free_abelian_group.{?l_1} β) (@functor.map.{?l_1 ?l_1} (λ {α : Type ?l_1}, free_abelian_group.{?l_1} α) (@applicative.to_functor.{?l_1 ?l_1} (λ {α : Type ?l_1}, free_abelian_group.{?l_1} α) (@monad.to_applicative.{?l_1 ?l_1} (λ {α : Type ?l_1}, free_abelian_group.{?l_1} α) free_abelian_group.monad.{?l_1})) α β f (@has_add.add.{?l_1} (free_abelian_group.{?l_1} α) (@add_semigroup.to_has_add.{?l_1} (free_abelian_group.{?l_1} α) (@add_monoid.to_add_semigroup.{?l_1} (free_abelian_group.{?l_1} α) (@add_group.to_add_monoid.{?l_1} (free_abelian_group.{?l_1} α) (@add_comm_group.to_add_group.{?l_1} (free_abelian_group.{?l_1} α) (free_abelian_group.add_comm_group.{?l_1} α))))) x y)) (@has_add.add.{?l_1} (free_abelian_group.{?l_1} β) (@add_semigroup.to_has_add.{?l_1} (free_abelian_group.{?l_1} β) (@add_monoid.to_add_semigroup.{?l_1} (free_abelian_group.{?l_1} β) (@add_group.to_add_monoid.{?l_1} (free_abelian_group.{?l_1} β) (@add_comm_group.to_add_group.{?l_1} (free_abelian_group.{?l_1} β) (free_abelian_group.add_comm_group.{?l_1} β))))) (@functor.map.{?l_1 ?l_1} free_abelian_group.{?l_1} (@applicative.to_functor.{?l_1 ?l_1} free_abelian_group.{?l_1} (@monad.to_applicative.{?l_1 ?l_1} free_abelian_group.{?l_1} free_abelian_group.monad.{?l_1})) α β f x) (@functor.map.{?l_1 ?l_1} free_abelian_group.{?l_1} (@applicative.to_functor.{?l_1 ?l_1} free_abelian_group.{?l_1} (@monad.to_applicative.{?l_1 ?l_1} free_abelian_group.{?l_1} free_abelian_group.monad.{?l_1})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='lime'><a title='α β : Type u,
f : free_abelian_group.{u} (α → β),
x y : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} β)
    (@free_abelian_group.lift.{u u} (α → β) (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)
       (λ (_x : α → β),
          @functor.map.{u u} free_abelian_group.{u}
            (@applicative.to_functor.{u u} free_abelian_group.{u}
               (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
            α
            β
            _x
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y))
       f)
    (@has_add.add.{u} (free_abelian_group.{u} β)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β)))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          β
          f
          x)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          β
          f
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  @@is_add_hom.map_add _ _ _ (@@free_abelian_group.is_add_group_hom_lift&#x27; (free_abelian_group β) _ _).to_is_add_hom _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_add_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_abelian_group.is_add_group_hom_lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 120, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : has_add.{u} α] [_inst_2 : has_add.{u} β] (f : α → β) [c : @is_add_hom.{u u} α β _inst_1 _inst_2 f] (x y : α), @eq.{u+1} β (f (@has_add.add.{u} α _inst_1 x y)) (@has_add.add.{u} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (β : Type u) [_inst_1 : add_comm_group.{u} β] (a : free_abelian_group.{u} α), @is_add_group_hom.{u u} (α → β) β (@pi.add_group.{u u} α (λ (a : α), β) (λ (i : α), @add_comm_group.to_add_group.{u} β _inst_1)) (@add_comm_group.to_add_group.{u} β _inst_1) (λ (f : α → β), @free_abelian_group.lift.{u u} α β _inst_1 f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
f : free_abelian_group.{u} (α → β),
x y : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} β)
    (@free_abelian_group.lift.{u u} (α → β) (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)
       (λ (_x : α → β),
          @functor.map.{u u} free_abelian_group.{u}
            (@applicative.to_functor.{u u} free_abelian_group.{u}
               (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
            α
            β
            _x
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y))
       f)
    (@has_add.add.{u} (free_abelian_group.{u} β)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β)))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          β
          f
          x)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          β
          f
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  @[simp] lemma seq_zero (f : free_abelian_group (α → β)) : f &lt;*&gt; 0 = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  is_add_group_hom.map_zero _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_group_hom.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{u} β] (f : α → β) [_inst_3 : @is_add_group_hom.{u u} α β _inst_1 _inst_2 f], @eq.{u+1} β (f (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β (@add_group.to_add_monoid.{u} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  @[simp] lemma seq_add (f : free_abelian_group (α → β)) (x y : free_abelian_group α) : f &lt;*&gt; (x + y) = (f &lt;*&gt; x) + (f &lt;*&gt; y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  is_add_hom.map_add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : has_add.{u} α] [_inst_2 : has_add.{u} β] (f : α → β) [c : @is_add_hom.{u u} α β _inst_1 _inst_2 f] (x y : α), @eq.{u+1} β (f (@has_add.add.{u} α _inst_1 x y)) (@has_add.add.{u} β _inst_2 (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  @[simp] lemma seq_neg (f : free_abelian_group (α → β)) (x : free_abelian_group α) : f &lt;*&gt; (-x) = -(f &lt;*&gt; x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  is_add_group_hom.map_neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_group_hom.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{u} β] (f : α → β) [_inst_3 : @is_add_group_hom.{u u} α β _inst_1 _inst_2 f] (a : α), @eq.{u+1} β (f (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  @[simp] lemma seq_sub (f : free_abelian_group (α → β)) (x y : free_abelian_group α) : f &lt;*&gt; (x - y) = (f &lt;*&gt; x) - (f &lt;*&gt; y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  is_add_group_hom.map_sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_group_hom.map_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : add_group.{u} β] (f : α → β) [_inst_3 : @is_add_group_hom.{u u} α β _inst_1 _inst_2 f] (a b : α), @eq.{u+1} β (f (@has_sub.sub.{u} α (@add_group_has_sub.{u} α _inst_1) a b)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β _inst_2) (f a) (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Additive group homomorphisms commute with subtraction.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  instance : is_lawful_monad free_abelian_group.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_lawful_monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (m : Type u → Type v) [_inst_1 : monad.{u v} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  { id_map := λ α x, free_abelian_group.induction_on&#x27; x (map_zero id) (λ x, map_pure id x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.induction_on&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} (f : α → β), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203      (λ x ih, by rw [map_neg, ih]) (λ x y ihx ihy, by rw [map_add, ihx, ihy]),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) y) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α α (@id.{u+1} α) y) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='α : Type u,
x : free_abelian_group.{u} α,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x))
    (@has_pure.pure.{u u} free_abelian_group.{u}
       (@applicative.to_has_pure.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       x)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_abelian_group.{u} α,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x))
    (@has_pure.pure.{u u} free_abelian_group.{u}
       (@applicative.to_has_pure.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       x)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          α
          (@id.{u+1} α)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='α : Type u,
x x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       x)
    x,
ihy :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       y)
    y
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       x)
    x,
ihy :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       y)
    y
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          α
          (@id.{u+1} α)
          x)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          α
          (@id.{u+1} α)
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       x)
    x,
ihy :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       α
       (@id.{u+1} α)
       y)
    y
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          α
          (@id.{u+1} α)
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    pure_bind := λ α β x f, pure_bind f x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.pure_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) f) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205    bind_assoc := λ α β γ x f g, free_abelian_group.induction_on&#x27; x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.induction_on&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → free_abelian_group.{u} γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206      (by iterate 3 { rw zero_bind }) (λ x, by iterate 2 { rw pure_bind })</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='free_abelian_group.zero_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='free_abelian_group.pure_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 158, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) f) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) f) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_zero.zero.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_zero.zero.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_zero.zero.{u} (free_abelian_group.{u} β)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β)))))
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_zero.zero.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (f x)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207      (λ x ih, by iterate 3 { rw neg_bind }; rw ih)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='free_abelian_group.neg_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 164, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x) f) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                x))
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x))
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_neg.neg.{u} (free_abelian_group.{u} β)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} β)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                x)
             f))
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x))
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                x))
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x))
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          x)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_neg.neg.{u} (free_abelian_group.{u} γ)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} γ)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ) (free_abelian_group.add_comm_group.{u} γ)))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          β
          γ
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                x)
             f)
          g))
    (@has_neg.neg.{u} (free_abelian_group.{u} γ)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} γ)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ) (free_abelian_group.add_comm_group.{u} γ)))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             x)
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208      (λ x y ihx ihy, by iterate 3 { rw add_bind }; rw [ihx, ihy]) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='free_abelian_group.add_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 161, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ x (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β y f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ y (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → free_abelian_group.{u} β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y) f) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β x f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ x (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} γ) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α β y f) g) (@has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) α γ y (λ (x : α), @has_bind.bind.{u u} free_abelian_group.{u} (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}) β γ (f x) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          x
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       x
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g)),
ihy :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          y
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       y
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             x
             y)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x
          y)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          x
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       x
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g)),
ihy :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          y
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       y
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_add.add.{u} (free_abelian_group.{u} β)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                      (free_abelian_group.add_comm_group.{u} β)))))
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             x
             f)
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             y
             f))
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x
          y)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          x
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       x
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g)),
ihy :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          y
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       y
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             x
             y)
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x
          y)
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          x
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       x
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g)),
ihy :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          y
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       y
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_add.add.{u} (free_abelian_group.{u} γ)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} γ)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} γ)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} γ)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ)
                   (free_abelian_group.add_comm_group.{u} γ)))))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          β
          γ
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             x
             f)
          g)
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          β
          γ
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             y
             f)
          g))
    (@has_add.add.{u} (free_abelian_group.{u} γ)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} γ)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} γ)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} γ)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ)
                   (free_abelian_group.add_comm_group.{u} γ)))))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          x
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          y
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β γ : Type u,
x : free_abelian_group.{u} α,
f : α → free_abelian_group.{u} β,
g : β → free_abelian_group.{u} γ,
x y : free_abelian_group.{u} α,
ihx :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          x
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       x
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g)),
ihy :
  @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       β
       γ
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          β
          y
          f)
       g)
    (@has_bind.bind.{u u} free_abelian_group.{u}
       (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
       α
       γ
       y
       (λ (x : α),
          @has_bind.bind.{u u} free_abelian_group.{u}
            (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
            β
            γ
            (f x)
            g))
⊢ @eq.{u+1} (free_abelian_group.{u} γ)
    (@has_add.add.{u} (free_abelian_group.{u} γ)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} γ)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} γ)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} γ)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ)
                   (free_abelian_group.add_comm_group.{u} γ)))))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          x
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          β
          γ
          (@has_bind.bind.{u u} free_abelian_group.{u}
             (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             α
             β
             y
             f)
          g))
    (@has_add.add.{u} (free_abelian_group.{u} γ)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} γ)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} γ)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} γ)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} γ)
                   (free_abelian_group.add_comm_group.{u} γ)))))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          x
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g))
       (@has_bind.bind.{u u} free_abelian_group.{u}
          (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
          α
          γ
          y
          (λ (x : α),
             @has_bind.bind.{u u} free_abelian_group.{u}
               (@monad.to_has_bind.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
               β
               γ
               (f x)
               g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  instance : is_comm_applicative free_abelian_group.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_comm_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (m : Type u_1 → Type u_2) [_inst_1 : applicative.{u_1 u_2} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  { commutative_prod := λ α β x y, free_abelian_group.induction_on&#x27; x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.induction_on&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212      (by rw [map_zero, zero_seq, seq_zero])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='free_abelian_group.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.zero_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.seq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 173, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 189, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_zero.zero.{u} (free_abelian_group.{u} (α → β)) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))))) x) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : free_abelian_group.{u} (α → β)), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_zero.zero.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α))))))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_zero.zero.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@has_zero.zero.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (β → prod.{u u} α β))))))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_zero.zero.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_zero.zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_zero.zero.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      (λ p, by rw [map_pure, pure_seq]; exact free_abelian_group.induction_on&#x27; y</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.pure_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.induction_on&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_has_seq.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β (@has_pure.pure.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_has_pure.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) (α → β) f) x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) → (∀ (x : α), C (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214        (by rw [map_zero, map_zero, zero_seq])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='free_abelian_group.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.zero_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 173, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))))) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_zero.zero.{u} (free_abelian_group.{u} (α → β)) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))))) x) (@has_zero.zero.{u} (free_abelian_group.{u} β) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_zero.zero.{u} (free_abelian_group.{u} β)
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β))))))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_zero.zero.{u} (free_abelian_group.{u} β)
             (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                      (free_abelian_group.add_comm_group.{u} β))))))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_zero.zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_zero.zero.{u} (free_abelian_group.{u} β)
             (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} β)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                      (free_abelian_group.add_comm_group.{u} β))))))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_zero.zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@has_zero.zero.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
          (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (α → prod.{u u} α β))))))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215        (λ q, by rw [map_pure, map_pure, pure_seq, map_pure])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='free_abelian_group.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.pure_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_has_seq.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β (@has_pure.pure.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_has_pure.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) (α → β) f) x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α x)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_pure.pure.{u u} free_abelian_group.{u}
       (@applicative.to_has_pure.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_pure.pure.{u u} free_abelian_group.{u}
       (@applicative.to_has_pure.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          (α → prod.{u u} α β)
          (λ (a : α), @prod.mk.{u u} α β a q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_pure.pure.{u u} free_abelian_group.{u}
       (@applicative.to_has_pure.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p q))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (λ (a : α), @prod.mk.{u u} α β a q)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216        (λ q ih, by rw [map_neg, map_neg, neg_seq, ih])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='free_abelian_group.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.neg_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 179, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : free_abelian_group.{u} (α → β)) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_neg.neg.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_has_neg.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))) f) x) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@prod.mk.{u u} α β p) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β q)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β q)) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_neg.neg.{u} (free_abelian_group.{u} β)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} β)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q)))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_neg.neg.{u} (free_abelian_group.{u} β)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β)))
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                β
                q)))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q)))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_neg.neg.{u} (free_abelian_group.{u} β)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} β)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                   (free_abelian_group.add_comm_group.{u} β)))
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                β
                q)))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q)))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@has_neg.neg.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                (free_abelian_group.add_comm_group.{u} (α → prod.{u u} α β))))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                β
                q)))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
q : β,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          q))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             q)))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                β
                q))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217        (λ y₁ y₂ ih1 ih2, by rw [map_add, map_add, add_seq, ih1, ih2]))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_abelian_group.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.add_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 176, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f g : free_abelian_group.{u} (α → β)) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_add.add.{u} (free_abelian_group.{u} (α → β)) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (α → β)) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))))) f g) x) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@prod.mk.{u u} α β p) y₁) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y₁) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@prod.mk.{u u} α β p) y₂) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y₂) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
y₁ y₂ : free_abelian_group.{u} β,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₁)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₁)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₂)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₂)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       (@has_add.add.{u} (free_abelian_group.{u} β)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                      (free_abelian_group.add_comm_group.{u} β)))))
          y₁
          y₂))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_add.add.{u} (free_abelian_group.{u} β)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                         (free_abelian_group.add_comm_group.{u} β)))))
             y₁
             y₂))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
y₁ y₂ : free_abelian_group.{u} β,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₁)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₁)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₂)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₂)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₁)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₂))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          (@has_add.add.{u} (free_abelian_group.{u} β)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β)
                         (free_abelian_group.add_comm_group.{u} β)))))
             y₁
             y₂))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
y₁ y₂ : free_abelian_group.{u} β,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₁)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₁)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₂)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₂)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₁)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₂))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@has_add.add.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → prod.{u u} α β))
                      (free_abelian_group.add_comm_group.{u} (α → prod.{u u} α β))))))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₁)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₂))
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
y₁ y₂ : free_abelian_group.{u} β,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₁)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₁)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₂)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₂)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₁)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₂))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₁)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₂)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
y₁ y₂ : free_abelian_group.{u} β,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₁)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₁)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@prod.mk.{u u} α β p)
       y₂)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y₂)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₁)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@prod.mk.{u u} α β p)
          y₂))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₁)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y₂)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218      (λ p ih, by rw [map_neg, neg_seq, seq_neg, ih])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.neg_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.seq_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 179, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 195, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p)) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : free_abelian_group.{u} (α → β)) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_neg.neg.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_has_neg.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))) f) x) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : free_abelian_group.{u} (α → β)) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} (free_abelian_group.{u} β) (@add_group.to_has_neg.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p)) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) (@has_pure.pure.{u u} free_abelian_group.{u} (@applicative.to_has_pure.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                p)))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@has_neg.neg.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                (free_abelian_group.add_comm_group.{u} (β → prod.{u u} α β))))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                p)))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                p))
          y))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
p : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_pure.pure.{u u} free_abelian_group.{u}
          (@applicative.to_has_pure.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          p))
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             (@has_pure.pure.{u u} free_abelian_group.{u}
                (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                α
                p))
          y))
    (@has_neg.neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          (@has_pure.pure.{u u} free_abelian_group.{u}
             (@applicative.to_has_pure.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219      (λ x₁ x₂ ih1 ih2, by rw [map_add, add_seq, seq_add, ih1, ih2]) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.add_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.seq_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 176, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 192, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) x₁) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) x₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) x₂) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@applicative.to_functor.{u u} (λ {α : Type u}, free_abelian_group.{u} α) (@monad.to_applicative.{u u} (λ {α : Type u}, free_abelian_group.{u} α) free_abelian_group.monad.{u})) α β f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f g : free_abelian_group.{u} (α → β)) (x : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β (@has_add.add.{u} (free_abelian_group.{u} (α → β)) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (α → β)) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (α → β)) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (α → β)) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (α → β)) (free_abelian_group.add_comm_group.{u} (α → β)))))) f g) x) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : free_abelian_group.{u} (α → β)) (x y : free_abelian_group.{u} α), @eq.{u+1} (free_abelian_group.{u} β) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} (free_abelian_group.{u} β) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} β) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} β) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} β) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} β) (free_abelian_group.add_comm_group.{u} β))))) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f x) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) x₁) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) x₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β)) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (β → prod.{u u} α β) (@prod.mk.{u u} α β) x₂) y) (@has_seq.seq.{u u} free_abelian_group.{u} (@applicative.to_has_seq.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) α (prod.{u u} α β) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) β (α → prod.{u u} α β) (λ (b : β) (a : α), @prod.mk.{u u} α β a b) y) x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
x₁ x₂ : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₁)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₁),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₂)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₂)
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             x₁
             x₂))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x₁
          x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
x₁ x₂ : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₁)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₁),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₂)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₂)
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@has_add.add.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (β → prod.{u u} α β))
                      (free_abelian_group.add_comm_group.{u} (β → prod.{u u} α β))))))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₁)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₂))
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x₁
          x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
x₁ x₂ : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₁)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₁),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₂)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₂)
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₁)
          y)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₂)
          y))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x₁
          x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
x₁ x₂ : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₁)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₁),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₂)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₂)
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₁)
          y)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₂)
          y))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          x₁)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α β : Type u,
x : free_abelian_group.{u} α,
y : free_abelian_group.{u} β,
x₁ x₂ : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₁)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₁),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       β
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (β → prod.{u u} α β)
          (@prod.mk.{u u} α β)
          x₂)
       y)
    (@has_seq.seq.{u u} free_abelian_group.{u}
       (@applicative.to_has_seq.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       α
       (prod.{u u} α β)
       (@functor.map.{u u} free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (α → prod.{u u} α β)
          (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
          y)
       x₂)
⊢ @eq.{u+1} (free_abelian_group.{u} (prod.{u u} α β))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          x₁)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          β
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             α
             (β → prod.{u u} α β)
             (@prod.mk.{u u} α β)
             x₂)
          y))
    (@has_add.add.{u} (free_abelian_group.{u} (prod.{u u} α β))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (prod.{u u} α β))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (prod.{u u} α β))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (prod.{u u} α β))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (prod.{u u} α β))
                   (free_abelian_group.add_comm_group.{u} (prod.{u u} α β))))))
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          x₁)
       (@has_seq.seq.{u u} free_abelian_group.{u}
          (@applicative.to_has_seq.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          α
          (prod.{u u} α β)
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             β
             (α → prod.{u u} α β)
             (λ (b : β) (a : α), @prod.mk.{u u} α β a b)
             y)
          x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  variable (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  instance [monoid α] : semigroup (free_abelian_group α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='semigroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  { mul := λ x, lift $ λ x₂, lift (λ x₁, of $ x₁ * x₂) x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    mul_assoc := λ x y z, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (λ (x : free_abelian_group.{u} α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) x₁
                            x₂))
                    x)))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (λ (x : free_abelian_group.{u} α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1))
                               x₁
                               x₂))
                       x)))
          x
          y)
       z)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (λ (x : free_abelian_group.{u} α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) x₁
                            x₂))
                    x)))
       x
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (λ (x : free_abelian_group.{u} α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1))
                               x₁
                               x₂))
                       x)))
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225      unfold has_mul.mul,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (λ (x : free_abelian_group.{u} α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) x₁
                            x₂))
                    x)))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (λ (x : free_abelian_group.{u} α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1))
                               x₁
                               x₂))
                       x)))
          x
          y)
       z)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (λ (x : free_abelian_group.{u} α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) x₁
                            x₂))
                    x)))
       x
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (λ (x : free_abelian_group.{u} α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1))
                               x₁
                               x₂))
                       x)))
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226      refine free_abelian_group.induction_on z rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227      { intros L3, rw [lift.of, lift.of],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@free_abelian_group.of.{u} α L3))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228        refine free_abelian_group.induction_on y rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229        { intros L2, iterate 3 { rw lift.of },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.of.{u} α L2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.of.{u} α L2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230          refine free_abelian_group.induction_on x rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231          { intros L1, iterate 3 { rw lift.of }, congr&#x27; 1, exact mul_assoc _ _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : semigroup.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α _inst_1) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α _inst_1) a b) c) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α _inst_1) a (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@free_abelian_group.of.{u} α L1)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@free_abelian_group.of.{u} α L1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1 L2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@free_abelian_group.of.{u} α L1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.of.{u} α
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)
          (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1 L2)
          L3))
    (@free_abelian_group.of.{u} α
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1
          (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α
⊢ @eq.{u+1} α
    (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1 L2)
       L3)
    (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L1
       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232          { intros L1 ih, iterate 3 { rw lift.neg }, rw ih },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2)) (@free_abelian_group.of.{u} α L1))) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3))) (@free_abelian_group.of.{u} α L1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@free_abelian_group.of.{u} α x)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@free_abelian_group.of.{u} α L1)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@free_abelian_group.of.{u} α L1))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L1))))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@free_abelian_group.of.{u} α L1)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@free_abelian_group.of.{u} α L1))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             (@free_abelian_group.of.{u} α L1))))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 L1 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@free_abelian_group.of.{u} α L1)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@free_abelian_group.of.{u} α L1))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             (@free_abelian_group.of.{u} α L1))))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          (@free_abelian_group.of.{u} α L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233          { intros x1 x2 ih1 ih2, iterate 3 { rw lift.add }, rw [ih1, ih2] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2)) x1)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3))) x1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2)) x2)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3))) x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            x))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         y) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α
              (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                 (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             x1
             x2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
          x2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α
            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L2))
             x2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α
               (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁
                  (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) L2 L3)))
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234        { intros L2 ih, iterate 4 { rw lift.neg }, rw ih },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.of.{u} α L2))) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.of.{u} α L2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.of.{u} α L2)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L2))))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.of.{u} α L2)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L2))))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 L2 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.of.{u} α L2)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L2))))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             (@free_abelian_group.of.{u} α L2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235        { intros y1 y2 ih1 ih2, iterate 4 { rw lift.add }, rw [ih1, ih2] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) y1)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) y1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) y2)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3)) y2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α
⊢ ∀ (x_1 y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            y))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            y)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α),
            @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             y1
             y2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y1))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          y2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          y2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α),
             @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  x)
             y2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₁ : α),
                @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ L3))
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      { intros L3 ih, iterate 3 { rw lift.neg }, rw ih },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) y)) (@free_abelian_group.of.{u} α L3)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) y) (@free_abelian_group.of.{u} α L3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@free_abelian_group.of.{u} α L3))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L3)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L3)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@free_abelian_group.of.{u} α L3))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L3)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          (@free_abelian_group.of.{u} α L3)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L3 : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@free_abelian_group.of.{u} α L3))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L3)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          (@free_abelian_group.of.{u} α L3)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      { intros z1 z2 ih1 ih2, iterate 2 { rw lift.add }, rw [ih1, ih2],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) y)) z1) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) y) z1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) y)) z2) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) x) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂)) y) z2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         x_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         y_1)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₂ : α),
                    @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)
                      (λ (x₁ : α),
                         @free_abelian_group.of.{u} α
                           (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                      x)
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α),
                 @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
              x)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α),
                    @free_abelian_group.of.{u} α
                      (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          z1
          z2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          z2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          z2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₂ : α),
                     @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                       (free_abelian_group.add_comm_group.{u} α)
                       (λ (x₁ : α),
                          @free_abelian_group.of.{u} α
                            (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                       x)
                  y))
          z2))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238        exact (lift.add _ _ _).symm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z1)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₂ : α),
                  @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                    (free_abelian_group.add_comm_group.{u} α)
                    (λ (x₁ : α),
                       @free_abelian_group.of.{u} α
                         (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                    x)
               y))
       z2)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α),
                  @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
               x)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
            x)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α),
                     @free_abelian_group.of.{u} α
                       (@semigroup.mul.{u} α (@monoid.to_semigroup.{u} α _inst_1) x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  instance [monoid α] : ring (free_abelian_group α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  { one := free_abelian_group.of 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    mul_one := λ x, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1))
             (@semigroup.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1))))
       x
       (@has_one.one.{u} (free_abelian_group.{u} α)
          (@has_one.mk.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.of.{u} α (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1))))))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244      unfold has_mul.mul semigroup.mul has_one.one,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1))
             (@semigroup.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1))))
       x
       (@has_one.one.{u} (free_abelian_group.{u} α)
          (@has_one.mk.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.of.{u} α (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1))))))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            x)
       (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245      rw lift.of,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            x)
       (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246      refine free_abelian_group.induction_on x rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247      { intros L, erw [lift.of], congr&#x27; 1, exact mul_one L },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 L (@monoid.one.{u} α _inst_1)))
    (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} α (@monoid.mul.{u} α _inst_1 L (@monoid.one.{u} α _inst_1)) L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248      { intros L ih, rw [lift.neg, ih] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1))) (@free_abelian_group.of.{u} α L)) (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249      { intros x1 x2 ih1 ih2, rw [lift.add, ih1, ih2] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1))) x1) x1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1))) x2) x2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ (@monoid.one.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    one_mul := λ x, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)
       (@free_abelian_group.of.{u} α (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252      unfold has_mul.mul semigroup.mul has_one.one,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)
       (@free_abelian_group.of.{u} α (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253      refine free_abelian_group.induction_on x rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254      { intros L, rw [lift.of, lift.of], congr&#x27; 1, exact one_mul L },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
       (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
    (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 (@monoid.one.{u} α _inst_1) L))
    (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} α (@monoid.mul.{u} α _inst_1 (@monoid.one.{u} α _inst_1) L) L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255      { intros L ih, rw [lift.neg, ih] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1))) (@free_abelian_group.of.{u} α L)) (@free_abelian_group.of.{u} α L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@free_abelian_group.of.{u} α x))
      (@free_abelian_group.of.{u} α x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_neg.neg.{u} (free_abelian_group.{u} α)
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@free_abelian_group.of.{u} α L))
    (@free_abelian_group.of.{u} α L)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L)))
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.of.{u} α L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256      { intros x1 x2 ih1 ih2, rw [lift.add, ih1, ih2] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1))) x1) x1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1))) x2) x2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x : free_abelian_group.{u} α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         x)
      x →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         y)
      y →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
          x1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x1)
    x1,
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       x2)
    x2
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@free_abelian_group.of.{u} α (@monoid.one.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       x1
       x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258    left_distrib := λ x y z, lift.add _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_1)))) (@free_abelian_group.lift.{u v} α β _inst_1 f x) (@free_abelian_group.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    right_distrib := λ x y z, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y)
       z)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
          x
          z)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260      unfold has_mul.mul semigroup.mul,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@has_mul.mk.{u} (free_abelian_group.{u} α)
          (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y)
       z)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
          x
          z)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@has_mul.mk.{u} (free_abelian_group.{u} α)
             (@semigroup.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.semigroup.{u} α _inst_1)))
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261      refine free_abelian_group.induction_on z rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262      { intros L, iterate 3 { rw lift.of }, rw lift.add, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          x
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          x)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ L))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263      { intros L ih, iterate 3 { rw lift.neg }, rw [ih, neg_add], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) (@free_abelian_group.of.{u} α L)) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) x) (@free_abelian_group.of.{u} α L)) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) y) (@free_abelian_group.of.{u} α L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_comm_group.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)))) a b)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))

α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@free_abelian_group.of.{u} α x_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@free_abelian_group.of.{u} α x_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@free_abelian_group.of.{u} α x_1))) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x_1)))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_neg.neg.{u} (free_abelian_group.{u} α)
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)))
               (@free_abelian_group.of.{u} α x_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α L)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          (@free_abelian_group.of.{u} α L)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@has_neg.neg.{u} (free_abelian_group.{u} α)
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.of.{u} α L))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          (@free_abelian_group.of.{u} α L)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L))))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α,
L : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@free_abelian_group.of.{u} α L))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@free_abelian_group.of.{u} α L))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@free_abelian_group.of.{u} α L)))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L))))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             (@free_abelian_group.of.{u} α L)))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             (@free_abelian_group.of.{u} α L))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264      { intros z1 z2 ih1 ih2, iterate 3 { rw lift.add }, rw [ih1, ih2],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) z1) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) x) z1) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) y) z1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) z2) (@has_add.add.{u} (free_abelian_group.{u} α) (@has_add.mk.{u} (free_abelian_group.{u} α) (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) x) z2) (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₂ : α), @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α) (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂)) y) z2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z : free_abelian_group.{u} α
⊢ ∀ (x_1 y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         x_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            x_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            x_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         y_1)
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            y_1)
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            y_1)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
         (λ (x₂ : α),
            @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
              (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
              (@has_add.add.{u} (free_abelian_group.{u} α)
                 (@has_add.mk.{u} (free_abelian_group.{u} α)
                    (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                 x
                 y))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x_1
            y_1))
      (@has_add.add.{u} (free_abelian_group.{u} α)
         (@has_add.mk.{u} (free_abelian_group.{u} α)
            (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 x)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1))
         (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₂ : α),
               @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                 (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                 y)
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                           (free_abelian_group.add_comm_group.{u} α)))))
               x_1
               y_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          z1
          z2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          z2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             z1
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          z2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               (@has_add.add.{u} (free_abelian_group.{u} α)
                  (@has_add.mk.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
                  x
                  y))
          z2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265        rw [add_assoc, add_assoc], congr&#x27; 1, apply add_left_comm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='add_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='add_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_semigroup.{u} α] (a b c : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) a b) c) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) a (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_semigroup.{u} α] (a b c : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) a b) c) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) a (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_comm_semigroup.{u} α] (a b c : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_comm_semigroup.to_add_semigroup.{u} α _inst_1)) a (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_comm_semigroup.to_add_semigroup.{u} α _inst_1)) b c)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_comm_semigroup.to_add_semigroup.{u} α _inst_1)) b (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_comm_semigroup.to_add_semigroup.{u} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@has_add.mk.{u} (free_abelian_group.{u} α)
                (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     x)
                z2)
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     y)
                z2))))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@has_add.mk.{u} (free_abelian_group.{u} α)
                (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     x)
                z2)
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     y)
                z2))))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2)
          (@has_add.add.{u} (free_abelian_group.{u} α)
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                         (free_abelian_group.add_comm_group.{u} α)))))
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     y)
                z1)
             (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                (λ (x₂ : α),
                   @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α)
                     (free_abelian_group.add_comm_group.{u} α)
                     (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                     y)
                z2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : monoid.{u} α,
x y z z1 z2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z1)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z1)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
            (@has_add.add.{u} (free_abelian_group.{u} α)
               (@has_add.mk.{u} (free_abelian_group.{u} α)
                  (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
               x
               y))
       z2)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@has_add.mk.{u} (free_abelian_group.{u} α)
          (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z2))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               y)
          z1)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@has_add.mk.{u} (free_abelian_group.{u} α)
             (@add_comm_group.add.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  x)
             z2)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                   (free_abelian_group.add_comm_group.{u} α)))))
       (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
          (λ (x₂ : α),
             @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
               (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
               x)
          z2)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z1)
          (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
             (λ (x₂ : α),
                @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
                  (λ (x₁ : α), @free_abelian_group.of.{u} α (@monoid.mul.{u} α _inst_1 x₁ x₂))
                  y)
             z2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267    .. free_abelian_group.add_comm_group α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group.add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u), add_comm_group.{u} (free_abelian_group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268    .. free_abelian_group.semigroup α }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group.semigroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 222, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : monoid.{u} α], semigroup.{u} (free_abelian_group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  instance [comm_monoid α] : comm_ring (free_abelian_group α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='comm_monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  { mul_comm := λ x y, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272      refine free_abelian_group.induction_on x (zero_mul y) _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : mul_zero_class.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α _inst_1) (@has_zero.zero.{u} α (@mul_zero_class.to_has_zero.{u} α _inst_1)) a) (@has_zero.zero.{u} α (@mul_zero_class.to_has_zero.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273      { intros s, refine free_abelian_group.induction_on y (zero_mul _).symm _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : mul_zero_class.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α _inst_1) (@has_zero.zero.{u} α (@mul_zero_class.to_has_zero.{u} α _inst_1)) a) (@has_zero.zero.{u} α (@mul_zero_class.to_has_zero.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274        { intros t, unfold has_mul.mul semigroup.mul ring.mul,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@free_abelian_group.of.{u} α t))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α t)
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.of.{u} α s))
       (@free_abelian_group.of.{u} α t))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275          iterate 4 { rw lift.of }, congr&#x27; 1, exact mul_comm _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : comm_semigroup.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@comm_semigroup.to_semigroup.{u} α _inst_1)) a b) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@comm_semigroup.to_semigroup.{u} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.of.{u} α s))
       (@free_abelian_group.of.{u} α t))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₁ : α),
          @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ t))
       (@free_abelian_group.of.{u} α s))
    (@free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
       (λ (x₂ : α),
          @free_abelian_group.lift.{u u} α (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)
            (λ (x₁ : α),
               @free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) x₁ x₂))
            (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) s t))
    (@free_abelian_group.of.{u} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) t s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α
⊢ @eq.{u+1} α (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) s t)
    (@monoid.mul.{u} α (@comm_monoid.to_monoid.{u} α _inst_1) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276        { intros t ih, rw [mul_neg_eq_neg_mul_symm, ih, neg_mul_eq_neg_mul] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='mul_neg_eq_neg_mul_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_mul_eq_neg_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b)) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) (@free_abelian_group.of.{u} α s) (@free_abelian_group.of.{u} α t)) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) (@free_abelian_group.of.{u} α t) (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         (@free_abelian_group.of.{u} α s))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@free_abelian_group.of.{u} α x))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@free_abelian_group.of.{u} α t))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α t)
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t)))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@free_abelian_group.of.{u} α t))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α t)
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
             (@ring.to_add_comm_group.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_abelian_group.{u} α)
                (@ring.to_semiring.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          (@free_abelian_group.of.{u} α s)
          (@free_abelian_group.of.{u} α t)))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@free_abelian_group.of.{u} α t))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α t)
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
             (@ring.to_add_comm_group.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semigroup.mk.{u} (free_abelian_group.{u} α)
                (@ring.mul.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
                (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          (@free_abelian_group.of.{u} α t)
          (@free_abelian_group.of.{u} α s)))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s t : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@free_abelian_group.of.{u} α t))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α t)
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t)))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α t))
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277        { intros y1 y2 ih1 ih2, rw [mul_add, add_mul, ih1, ih2] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : distrib.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) b c)) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a b) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : distrib.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) a b) c) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a c) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) (@free_abelian_group.of.{u} α s) y1) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) y1 (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) (@free_abelian_group.of.{u} α s) y2) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) y2 (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α
⊢ ∀ (x y : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         x)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α s)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α s)
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y))
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y)
         (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y1)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y1
       (@free_abelian_group.of.{u} α s)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y2)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y2
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          y1
          y2))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          y1
          y2)
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y1)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y1
       (@free_abelian_group.of.{u} α s)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y2)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y2
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          (@free_abelian_group.of.{u} α s)
          y1)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          (@free_abelian_group.of.{u} α s)
          y2))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          y1
          y2)
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y1)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y1
       (@free_abelian_group.of.{u} α s)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y2)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y2
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          (@free_abelian_group.of.{u} α s)
          y1)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          (@free_abelian_group.of.{u} α s)
          y2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y1
          (@free_abelian_group.of.{u} α s))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y2
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y1)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y1
       (@free_abelian_group.of.{u} α s)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y2)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y2
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semigroup.mk.{u} (free_abelian_group.{u} α)
                (@ring.mul.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
                (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          y1
          (@free_abelian_group.of.{u} α s))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          (@free_abelian_group.of.{u} α s)
          y2))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y1
          (@free_abelian_group.of.{u} α s))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y2
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
y1 y2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y1)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y1
       (@free_abelian_group.of.{u} α s)),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y2)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y2
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          y1
          y2))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          y1
          y2)
       (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      { intros s ih, rw [neg_mul_eq_neg_mul_symm, ih, neg_mul_eq_mul_neg] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='neg_mul_eq_neg_mul_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_mul_eq_mul_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) a) b) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) (@free_abelian_group.of.{u} α s) y) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) y (@free_abelian_group.of.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))

α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x : α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@free_abelian_group.of.{u} α x)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@free_abelian_group.of.{u} α x)) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x))
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_neg.neg.{u} (free_abelian_group.{u} α)
            (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
               (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                  (free_abelian_group.add_comm_group.{u} α)))
            (@free_abelian_group.of.{u} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s))
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
             (@ring.to_add_comm_group.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_abelian_group.{u} α)
                (@ring.to_semiring.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          (@free_abelian_group.of.{u} α s)
          y))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_neg.neg.{u} (free_abelian_group.{u} α)
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
             (@ring.to_add_comm_group.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semigroup.mk.{u} (free_abelian_group.{u} α)
                (@ring.mul.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
                (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          y
          (@free_abelian_group.of.{u} α s)))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α,
s : α,
ih :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@free_abelian_group.of.{u} α s)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@free_abelian_group.of.{u} α s))
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s))
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_neg.neg.{u} (free_abelian_group.{u} α)
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} α)
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)))
          (@free_abelian_group.of.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      { intros x1 x2 ih1 ih2, rw [add_mul, mul_add, ih1, ih2] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : distrib.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) a b) c) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a c) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : distrib.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) b c)) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a b) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) x1 y) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) y x1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_abelian_group.{u} α) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) x2 y) (@has_mul.mul.{u} (free_abelian_group.{u} α) (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α) (@semigroup.mk.{u} (free_abelian_group.{u} α) (@ring.mul.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))) (@ring.mul_assoc.{u} (free_abelian_group.{u} α) (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))) y x2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y : free_abelian_group.{u} α
⊢ ∀ (x y_1 : free_abelian_group.{u} α),
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         x
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         x) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y_1
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         y_1) →
    @eq.{u+1} (free_abelian_group.{u} α)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1)
         y)
      (@has_mul.mul.{u} (free_abelian_group.{u} α)
         (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
            (@semigroup.mk.{u} (free_abelian_group.{u} α)
               (@ring.mul.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
               (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                  (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
         y
         (@has_add.add.{u} (free_abelian_group.{u} α)
            (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
               (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                  (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                     (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                        (free_abelian_group.add_comm_group.{u} α)))))
            x
            y_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x1
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x2
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x1
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x2
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          x1
          y)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          x2
          y))
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x1
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x2
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          x1
          y)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          x2
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y
          x1)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x1
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x2
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
             (@semigroup.mk.{u} (free_abelian_group.{u} α)
                (@ring.mul.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
                (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                   (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
          y
          x1)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          x2
          y))
    (@has_add.add.{u} (free_abelian_group.{u} α)
       (@distrib.to_has_add.{u} (free_abelian_group.{u} α)
          (@ring.to_distrib.{u} (free_abelian_group.{u} α)
             (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y
          x1)
       (@has_mul.mul.{u} (free_abelian_group.{u} α)
          (@distrib.to_has_mul.{u} (free_abelian_group.{u} α)
             (@ring.to_distrib.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1))))
          y
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : comm_monoid.{u} α,
x y x1 x2 : free_abelian_group.{u} α,
ih1 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x1
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x1),
ih2 :
  @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       x2
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       x2)
⊢ @eq.{u+1} (free_abelian_group.{u} α)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2)
       y)
    (@has_mul.mul.{u} (free_abelian_group.{u} α)
       (@semigroup.to_has_mul.{u} (free_abelian_group.{u} α)
          (@semigroup.mk.{u} (free_abelian_group.{u} α)
             (@ring.mul.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))
             (@ring.mul_assoc.{u} (free_abelian_group.{u} α)
                (@free_abelian_group.ring.{u} α (@comm_monoid.to_monoid.{u} α _inst_1)))))
       y
       (@has_add.add.{u} (free_abelian_group.{u} α)
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α)
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α)
                      (free_abelian_group.add_comm_group.{u} α)))))
          x1
          x2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    .. free_abelian_group.ring α }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group.ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 241, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : monoid.{u} α], ring.{u} (free_abelian_group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  end free_abelian_group</code></pre>
</body>